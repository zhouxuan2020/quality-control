[["related-individuals.html", "10 related individuals 10.1 \\(\\overline{r^2_j}\\) &amp; relatedness 10.2 GWAS 10.3 organize data 10.4 summary 10.5 Hapmap3 genotype data 10.6 mix unrel &amp; rel", " 10 related individuals 10.1 \\(\\overline{r^2_j}\\) &amp; relatedness Previously we performed analyses on icd10 traits using related individuals. Here are relevant files: bfile: gen/geno-rel: created using icd10/related.inds id lists: 56757 icd10/related.inds 56754 relatedness/cut.05.related: relatedness &gt;= 0.05. 56753 relatedness/cut.125.related 48197 relatedness/cut.25.related 18294 relatedness/cut.5.related snp list after QC: gen/snps-rel-inds.use : 627,320 SNPs #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # create id lists &amp; snp lists #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # unrelated ids---------------------------------------------------------------- # serve as control groups n=(56753 48197 18294) nm=(cut.125 cut.25 cut.5) for i in {0..2}; do shuf rand.100000 | head -n ${n[$i]} &gt; white-unrel-rand-control-for-${nm[$i]} done # snp list---------------------------------------------------------------------- # common snps of related &amp; unrelated unrel=gen/snps-unrel-inds.use # 1,103,209 rel=gen/snps-rel-inds.use # 627,320 SNPs awk &#39;NR==FNR{a[$1];next} ($1 in a) {print $1}&#39; $unrel $rel &gt; gen/common-unrel-rel-snps # 153,313 # lista &amp; listb # this will be common for all id lists m=10000 infile=gen/common-unrel-rel-snps left=inflation/related/left-snps right=inflation/related/right-snps awk &#39;{split($1, a, &quot;:&quot;); if (a[1]&lt;8) print $1 }&#39; $infile | shuf | head -n $m &gt;$left awk &#39;{split($1, a, &quot;:&quot;); if (a[1]&gt;=8) print $1 }&#39; $infile | shuf | head -n $m &gt;$right #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # compute ave r^2_j #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: for nm in {cut.125,cut.25,cut.5}; do # common snp lists lista=../inflation/related/right-snps listb=../inflation/related/left-snps # related individuals id=../relatedness/$nm.related bfile=../gen/geno-rel out=../inflation/related/out/10k-snps-$nm-rel echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 2 #SBATCH -t 00:10:0 ./ldak5.2 --max-threads 2 \\ --calc-inflation $out \\ --bfile $bfile \\ --keep $id \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-r-10k-snps-$nm-rel # unrelated controls id=../white-unrel-rand-control-for-$nm bfile=../gen/geno-unrel out=../inflation/related/out/10k-snps-$nm-unrel echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 2 #SBATCH -t 00:10:0 ./ldak5.2 --max-threads 2 \\ --calc-inflation $out \\ --bfile $bfile \\ --keep $id \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-r-10k-snps-$nm-unrel done # submit the job for nm in {cut.125,cut.25,cut.5}; do sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-rel sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-unrel done&gt;../job-records/calc-r-related # compute ave r_j^2 for each i------------------------------------------------- R require(vroom) cut=c(&quot;cut.125&quot;,&quot;cut.25&quot;,&quot;cut.5&quot;) rel=c(&quot;rel&quot;,&quot;unrel&quot;) for(j in 1:length(rel)){ for(i in 1:length(cut)){ nm=paste0(&quot;10k-snps-&quot;,cut[i],&quot;-&quot;,rel[j]) dat=vroom(paste0(&quot;inflation/related/out/&quot;,nm,&quot;.pairwise&quot;), col_names=F) lista=read.table(paste0(&quot;inflation/related/out/&quot;,nm,&quot;.predictorsa&quot;), stringsAsFactors = F) listb=read.table(paste0(&quot;inflation/related/out/&quot;,nm,&quot;.predictorsb&quot;), stringsAsFactors = F) dat=dat[,-c(10001)]^2 outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean)) outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean)) out=rbind(outa,outb) write.table(out,paste0(&quot;summary/ave-r2-&quot;,nm), col.names=F, row.names=F, quote=F) } } #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # summary #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # check if mean r^2_j differs for rel vs. unrel cut=c(&quot;cut.125&quot;,&quot;cut.25&quot;,&quot;cut.5&quot;) for(i in 1:length(cut)){ nm_rel=paste0(&quot;ave-r2-10k-snps-&quot;,cut[i],&quot;-rel&quot;) nm_unrel=paste0(&quot;ave-r2-10k-snps-&quot;,cut[i],&quot;-unrel&quot;) dat_rel=read.table(paste0(&quot;summary/&quot;,nm_rel),stringsAsFactors = F) dat_unrel=read.table(paste0(&quot;summary/&quot;,nm_unrel),stringsAsFactors = F) out0=data.frame(rel=cut[i], rel_ave=mean(dat_rel$V2), rel_sd=sd(dat_rel$V2), unrel_ave=mean(dat_unrel$V2), unrel_sd=sd(dat_unrel$V2), stringsAsFactors = F) if(i==1){out1=out0}else{out1=rbind(out1,out0)} } 10.2 GWAS # create directories------------------------------------------------------------ for j in {cut.125,cut.25,cut.5}; do for i in {rel,unrel};do mkdir gwas-$j-$i done done # gwas ------------------------------------------------------------------------- for j in {cut.125,cut.25,cut.5}; do for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do # related individuals---------------------- out=../gwas-$j-rel/$i-linear id=../relatedness/$j.related snp=../gen/snps-rel-inds.use bfile=../gen/geno-rel echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 1 #SBATCH -t 8:0:0 ./ldak5.1 --linear $out \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile $bfile \\ --keep $id \\ --extract $snp \\ --covar ../phen/covariates.use \\ --max-threads 2 \\ &quot;&gt; sh_script/$i-linear-$j-rel.sh # unrelated individuals---------------------- out=../gwas-$j-unrel/$i-linear id=../white-unrel-rand-control-for-$j snp=../gen/snps-unrel-inds.use bfile=../gen/geno-unrel echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 1 #SBATCH -t 8:0:0 ./ldak5.1 --linear $out \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile $bfile \\ --keep $id \\ --extract $snp \\ --covar ../phen/covariates.use \\ --max-threads 2 \\ &quot;&gt; sh_script/$i-linear-$j-unrel.sh done done # submit jobs for j in {cut.125,cut.25,cut.5}; do for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear-$j-rel.sh sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh done done&gt;../job-records/gwas-related # check job completion file=job-records/gwas-related jobs=`awk &#39;{print $4}&#39; $file` mkdir $file-tmp for i in $jobs; do jobinfo $i | awk -F &quot;:&quot; -v i=$i &#39;$1~/Name/ {print i, $2}&#39; &gt;&gt; $file-tmp/name.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/State/ {print$2}&#39; &gt;&gt; $file-tmp/state.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Cores/ {print$2}&#39; &gt;&gt; $file-tmp/cores.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Used walltime/ {print $2 &quot;:&quot; $3 &quot;:&quot; $4}&#39; &gt;&gt; $file-tmp/time.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}&#39; &gt;&gt; $file-tmp/mem.tmp done paste $file-tmp/name.tmp \\ $file-tmp/state.tmp \\ $file-tmp/cores.tmp \\ $file-tmp/time.tmp \\ $file-tmp/mem.tmp \\ | awk &#39;BEGIN{print &quot;ID name state cores time mem&quot;}{print $0}&#39; &gt; $file.out rm -r $file-tmp 10.3 organize data #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # compute MAF #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: for j in {cut.125,cut.25,cut.5}; do for i in {rel,unrel};do out=../gen/maf/geno-$j-$i if [ $i == rel ]; then bfile=../gen/geno-rel id=../relatedness/$j.related else bfile=../gen/geno-unrel id=../white-unrel-rand-control-for-$j fi echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 10G #SBATCH -c 2 #SBATCH -t 5:0:0 ./ldak5.1 --calc-stats $out \\ --bfile $bfile \\ --keep $id &quot;&gt; sh_script/calc-maf-$j-$i.sh done done # submit script for j in {cut.125,cut.25,cut.5}; do for i in {rel,unrel};do sbatch -A snpher ../sh_script/calc-maf-$j-$i.sh done done&gt;../job-records/calc-maf-rel #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # extract LD scores #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # we do this for related individuals. # ld scores of snp list for unrelated id: snps-unrel-maf.001.ldscore # convert snp list to rs system ------------------------------------------------ infile=gen/snps-rel-inds.use outfile=gen/snps-rel-rs awk &#39;(NR==FNR){a[$1]; b[$1]=$2; next} ($1 in a){print b[$1], $2}&#39; doug/ukbb.ldsc $infile &gt; $outfile # extract ld scores ----------------------------------------------------------- dir=ldsc/eur_w_ld_chr for chrom in {1..22}; do zcat $dir/$chrom.l2.ldscore.gz | awk &#39;NR&gt;1 {print $2, $6}&#39; &gt; ldscore awk &#39;(NR==FNR){a[$1];next}($1 in a){print $0}&#39; gen/snps-rel-rs ldscore &gt; temp if [ $chrom -eq 1 ] then mv temp snps-rel.ldscore else cat snps-rel.ldscore temp &gt; temp2 mv temp2 snps-rel.ldscore fi echo $chrom done #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # put info together #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: # maf: gen/maf/geno-[cut.125]-[rel] # chi square : gwas-[cut.125]-[rel]/[trait]-linear.summaries # ave r^2_j: summary/ave-r2-10k-snps-[cut.25]-[unrel] # ld score from ldsc ref panel: snps-unrel-maf.001.ldscore; snps-rel.ldscore # fixed file rs=doug/ukbb.ldsc for j in {cut.125,cut.25,cut.5}; do for i in {rel,unrel};do # files vary depending on j &amp;/or i maf=gen/maf/geno-$j-$i.stats # use as the snp list to integrate all info aver2=summary/ave-r2-10k-snps-$j-$i if [ $i == rel ]; then ldsc=snps-rel.ldscore else ldsc=snps-unrel-maf.001.ldscore fi # create temporary files awk &#39;NR &gt; 1 {print $1, $5 }&#39; $maf &gt; tmp/maf.tmp awk &#39;NR==FNR {a[$2]; b[$2]=$1; next} ($1 in a) {print b[$1], $0}&#39; $rs $ldsc &gt; tmp/ldsc.tmp1 # here we make sure the order of the rows are the same as maf.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; c[$1]=$3 ; next} {if ($1 in a) print b[$1], c[$1]; else print &quot;NA&quot;}&#39; tmp/ldsc.tmp1 tmp/maf.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/maf.tmp &gt; tmp/aver2.tmp for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do # files vary with j, i and trait gwas=gwas-$j-$i/$trait-linear.summaries out=gwas-related-all-out/$trait-$j-$i.out awk &#39;NR==FNR {a[$1]; b[$1]=$5; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $gwas tmp/maf.tmp &gt; tmp/gwas.tmp # put info together paste tmp/maf.tmp \\ tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;maf;chisq;aver2;rs;ldsc&quot;} {$1=$1}1&#39; &gt; $out done done done 10.4 summary #:::::::::::::::::::::::::::::::::::::::::::::: # estimate slope: chisq ~ aver2_j #:::::::::::::::::::::::::::::::::::::::::::::: require(vroom) #cuts=c(&quot;cut.125&quot;,&quot;cut.25&quot;,&quot;cut.5&quot;) cuts=&quot;cut.125&quot; related=c(&quot;rel&quot;,&quot;unrel&quot;) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) for(i in 1:length(related)){ for(j in 1:length(cuts)){ for(k in 1:length(traits)){ rel=related[i] cut=cuts[j] trait=traits[k] file=paste0(&quot;gwas-related-all-out/&quot;,trait,&quot;-&quot;,cut, &quot;-&quot;,rel,&quot;.out&quot;) dat=vroom(file, col_names=T, delim=&quot;;&quot;) mod=lm(chisq ~ aver2,data=dat) slope0=data.frame(trait=trait, cutoff=cut, rel=rel, slope_aver2=coef(mod)[2], p_aver2=summary(mod)$coefficients[,4][2], stringsAsFactors = F) if(i==1 &amp; j==1 &amp; k==1){slope=slope0} else {slope=rbind(slope,slope0)} } } } out=slope[order(slope$trait, slope$cutoff, slope$rel),] #write.table(out,&quot;summary/chisq-aver2-slope-gwas-related.txt&quot;, # col.names=T, row.names=F, quote=F) #:::::::::::::::::::::::::::::::::::::::::::::: # plot chisq ~ aver2_j by rel | cut #:::::::::::::::::::::::::::::::::::::::::::::: # function to plot a single trait--------------------------------------------------- make_plot=function(trait, cut){ # define variables cut=cut trait=trait # define color library(RColorBrewer) qual_col_pals = brewer.pal.info[brewer.pal.info$category == &#39;qual&#39;,] col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) set.seed(14) mycol=sample(col_vector,2) # related file1=paste0(&quot;gwas-related-all-out/&quot;,trait,&quot;-&quot;,cut,&quot;-rel.out&quot;) dat1=vroom(file1, col_names=T, delim=&quot;;&quot;) # bin a variable by quantile cutoff=quantile(dat1$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat1$bin=cut(dat1$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out1=data.frame(chisq_ave=tapply(dat1$chisq,INDEX=dat1$bin, mean)) out1$bin_val=tapply(dat1$aver2,INDEX=dat1$bin, mean) # unrelated file2=paste0(&quot;gwas-related-all-out/&quot;,trait,&quot;-&quot;,cut,&quot;-unrel.out&quot;) dat2=vroom(file2, col_names=T, delim=&quot;;&quot;) # bin a variable by quantile cutoff=quantile(dat2$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat2$bin=cut(dat2$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out2=data.frame(chisq_ave=tapply(dat2$chisq,INDEX=dat2$bin, mean)) out2$bin_val=tapply(dat2$aver2,INDEX=dat2$bin, mean) xstart=min(out1$bin_val,out2$bin_val) xend=max(out1$bin_val,out2$bin_val) ystart=min(out1$chisq_ave,out2$chisq_ave) yend=max(out1$chisq_ave,out2$chisq_ave) plot(out1$bin_val, out1$chisq_ave, xlab=&quot;ave r2&quot;, ylab=&quot;ave chisq&quot;, xlim=c(xstart,xend), ylim=c(ystart,yend), main=paste0(trait,&quot; &quot;, cut), las=1, cex = 1.5, pch=21, bg=mycol[1], col=&quot;white&quot;, lwd=0.5) points(out2$bin_val, out2$chisq_ave, cex = 1.5, pch=21, col=&quot;white&quot;, bg=mycol[2], lwd=0.5) if(trait==&quot;awake&quot;){ legend(&quot;topleft&quot;, pch=19, legend=c(&quot;rel&quot;,&quot;unrel&quot;), col=mycol, cex=1.5, box.lty=0)} } # end of function # make a plot ------------------------------------------------------------------ require(vroom) cuts=c(&quot;cut.125&quot;,&quot;cut.25&quot;,&quot;cut.5&quot;) related=c(&quot;rel&quot;,&quot;unrel&quot;) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) for(j in 1:length(cuts)){ cut=cuts[j] # plot chisq ~ aver2 by rel for a given cutoff for relatedness png(paste0(&quot;fig/chisq-by-aver2-bin-related-gwas-&quot;,cut,&quot;.png&quot;), width = 50, height = 30, units = &quot;cm&quot;, res=600) par(mfrow=c(3,5)) for(i in 1:length(traits)){ trait=traits[i] make_plot(trait, cut) } dev.off() } 10.5 Hapmap3 genotype data #::: # make bfiles by chromosome #:::: for j in {1..22}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 3 #SBATCH -t 1:0:0 ./plink2 --pfile ../gen/geno_plink/bhr$j \\ --keep ../icd10/related.inds \\ --extract ../doug/ukbb.ldsc \\ --hwe 0.0001 \\ --hard-call-threshold .05 \\ --mach-r2-filter 0.8 2 \\ --make-bed \\ --memory 20000 \\ --out ../gen/tmp/bhr$j \\ --threads 3 \\ &quot;&gt; sh_script/chr$j.sh done # submit script for i in {1..22}; do sbatch -A snpher ../sh_script/chr$i.sh done&gt;../job-records/mkbfile-related # check job completion file=job-records/mkbfile-related jobs=`awk &#39;{print $4}&#39; $file` mkdir $file-tmp for i in $jobs; do jobinfo $i | awk -F &quot;:&quot; -v i=$i &#39;$1~/Name/ {print i, $2}&#39; &gt;&gt; $file-tmp/name.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/State/ {print$2}&#39; &gt;&gt; $file-tmp/state.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Cores/ {print$2}&#39; &gt;&gt; $file-tmp/cores.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Used walltime/ {print $2 &quot;:&quot; $3 &quot;:&quot; $4}&#39; &gt;&gt; $file-tmp/time.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}&#39; &gt;&gt; $file-tmp/mem.tmp done paste $file-tmp/name.tmp \\ $file-tmp/state.tmp \\ $file-tmp/cores.tmp \\ $file-tmp/time.tmp \\ $file-tmp/mem.tmp \\ | awk &#39;BEGIN{print &quot;ID name state cores time mem&quot;}{print $0}&#39; &gt; $file.out rm -r $file-tmp #::::: # merge bfiles #:::: rm bfile.list for j in {1..22}; do echo &quot;../gen/tmp/bhr$j&quot; &gt;&gt;bfile.list done echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 3 #SBATCH -t 40:0:0 ./ldak5.1 --make-bed ../gen/geno-rel-hmp3 \\ --mbfile ../gen/bfile.list \\ --max-threads 3 \\ --exclude-dups YES &quot;&gt; sh_script/mbfile.sh # submit the script sbatch -A snpher ../sh_script/mbfile.sh &gt;../job-records/mbfiles-related # snp list -------------------------------------------------------------------- # MAF &amp; call-rate awk &lt; gen/geno-rel-hmp3.stats &#39;($5&gt;.01 &amp;&amp; $6&gt;=0.95 &amp;&amp; NR&gt;1) {print $1}&#39; &gt; gen/snps-rel-hmp3.use # m = 2,284,197 SNPs # gwas ------------------------------------------------------------------------- #for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do #for j in {cut.125,cut.25,cut.5}; do i=height j=cut.125 for chr in {1..22}; do id=../relatedness/$j.related snp=../gen/snps-rel-hmp3.use bfile=../gen/geno-rel-hmp3 out=../gwas-$j-rel/$i-linear-$chr echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 1 #SBATCH -t 8:0:0 ./ldak5.1 --linear $out \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile $bfile \\ --keep $id \\ --extract $snp \\ --covar ../phen/covariates.use \\ --max-threads 2 \\ --chr $chr &quot;&gt; sh_script/$i-linear-$j-rel-chr-$chr.sh done #done #done # submit jobs i=height j=cut.125 for chr in {1..22}; do #for j in {cut.125,cut.25,cut.5}; do #for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear-$j-rel-chr-$chr.sh #sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh #done done&gt;../job-records/gwas-related 10.6 mix unrel &amp; rel #::: # make bfiles by chromosome #:::: for j in {1..22}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 3 #SBATCH -t 1:0:0 ./plink2 --pfile ../gen/geno_plink/bhr$j \\ --keep ../rel-unrel-combo.id \\ --extract ../doug/ukbb.ldsc \\ --hwe 0.0001 \\ --hard-call-threshold .05 \\ --mach-r2-filter 0.8 2 \\ --make-bed \\ --memory 20000 \\ --out ../gen/tmp/bhr$j-combo \\ --threads 3 \\ &quot;&gt; sh_script/chr$j.sh done # submit script for i in {1..22}; do sbatch -A snpher ../sh_script/chr$i.sh done&gt;../job-records/mkbfile-related-unrel-combo # check job completion file=job-records/mkbfile-related-unrel-combo jobs=`awk &#39;{print $4}&#39; $file` mkdir $file-tmp for i in $jobs; do jobinfo $i | awk -F &quot;:&quot; -v i=$i &#39;$1~/Name/ {print i, $2}&#39; &gt;&gt; $file-tmp/name.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/State/ {print$2}&#39; &gt;&gt; $file-tmp/state.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Cores/ {print$2}&#39; &gt;&gt; $file-tmp/cores.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Used walltime/ {print $2 &quot;:&quot; $3 &quot;:&quot; $4}&#39; &gt;&gt; $file-tmp/time.tmp jobinfo $i | awk -F &quot;:&quot; &#39;$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}&#39; &gt;&gt; $file-tmp/mem.tmp done paste $file-tmp/name.tmp \\ $file-tmp/state.tmp \\ $file-tmp/cores.tmp \\ $file-tmp/time.tmp \\ $file-tmp/mem.tmp \\ | awk &#39;BEGIN{print &quot;ID name state cores time mem&quot;}{print $0}&#39; &gt; $file.out rm -r $file-tmp #::::: # merge bfiles #:::: rm bfile.list for j in {1..22}; do echo &quot;../gen/tmp/bhr$j-combo&quot; &gt;&gt;bfile.list done echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 3 #SBATCH -t 40:0:0 ./ldak5.1 --make-bed ../gen/geno-rel-unrel-combo \\ --mbfile ../gen/bfile.list \\ --max-threads 3 \\ --exclude-dups YES &quot;&gt; sh_script/mbfile.sh # submit the script # id list---------------------------------------------------------------- # non-overlapping list awk &#39;NR==FNR {a[$1]; next} !($1 in a) {print }&#39; icd10/related.inds unrelated/rand.100000 &gt; tmp.txt sbatch -A snpher ../sh_script/mbfile.sh &gt;../job-records/mbfiles-rel-unrel-combo rm tmp "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
