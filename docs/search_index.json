[["fine-scale-population-stratification.html", "18 Fine-scale population stratification 18.1 birth location data 18.2 pca of 337k 18.3 birth place gwas 18.4 GWAS based on PC clusters 18.5 compute aver2 18.6 chisq ~ aver2 18.7 inflation ~ aver2", " 18 Fine-scale population stratification 18.1 birth location data # extract raw phenotype data ---------------------------------------------------- options(scipen = 100) head=read.table(&quot;phen/ukb45861.header&quot;, sep=&quot;,&quot;, header=F, stringsAsFactors = F) # function to get the variables get=function(nm){ colnum=grep(nm,head,fixed=TRUE) out=data.frame(t(rbind(colnum, head[,colnum]))) names(out)=c(&quot;column&quot;, &quot;field&quot;) return (out) } # get the variables out=rbind(get(&#39;129-&#39;), # east co-ordinate: birth place in UK get(&#39;130-&#39;)) # north co-ordinate: birth place in UK # only select the right variables out=out[c(1:3, 20:22),] write.table(out,&quot;phen/birth-place.colnum&quot;, col.names=F, row.names=F, sep=&quot;\\t&quot;, quote=F) # extract dat------------------------------------------------------------------- awk -F &#39;&quot;,&quot;&#39; &#39;(NR==FNR){a[$1];next} {printf &quot;%s\\&quot;&quot;, $1; for(i in a){printf &quot; \\&quot;%s\\&quot;&quot;, $i}; printf &quot;\\n&quot;}&#39; phen/birth-place.colnum phen/ukb45861.csv &gt; phen/birth-place.dat # organize dat------------------------------------------------------------------ mkdir phen/other-traits dat=read.table(&quot;phen/birth-place.dat&quot;, header=T, stringsAsFactors=F) cov=read.table(&quot;phen/covariates.phen&quot;, header=T, stringsAsFactors=F) m=match(dat$eid,cov$eid) cov=cov[m,] # -1 = unknown location dat1=dat for(i in 2:7){ dat1[dat[,i]==-1 &amp; !is.na(dat[,i]),i]=&quot;NA&quot; } # note: Cook 2020 p.2804 mentioned that # &quot;We excluded individuals with missing birth location and # those from the pilot study at the Stockport recruitment (centre code10003) # center for which the Cartesian coordinates were incorrect. # exclude stockport centre dat1[cov$centre==10003 &amp; !is.na(cov$centre),&quot;X130.0.0&quot;]=&quot;NA&quot; dat1[cov$centre==10003 &amp; !is.na(cov$centre),&quot;X129.0.0&quot;]=&quot;NA&quot; # note: we only use the baseline data write.table(cbind(dat1[,1],dat[,1], dat[,7]), &quot;phen/other-traits/east-coord-birth-place.raw.pheno&quot;, col.names=F, row.names=F, quote=F) write.table(cbind(dat1[,1],dat[,1], dat[,6]), &quot;phen/other-traits/north-coord-birth-place.raw.pheno&quot;, col.names=F, row.names=F, quote=F) 18.2 pca of 337k # Prune snps echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --partition normal #SBATCH --mem 10G #SBATCH -c 4 #SBATCH -t 10:0:0 #SBATCH --constraint \\&quot;s04|s05\\&quot; ./ldak5.1 --max-threads 4 \\ --window-prune 0.05 \\ --window-kb 1000 \\ --extract ../gen/snps-norm.use \\ --bfile ../gen/geno-norm \\ --keep ../ukbb-recommend.id \\ --thin ../thin/thin-geno-norm &quot; &gt; sh_script/thin-geno-norm sbatch -A snpher ../sh_script/thin-geno-norm-chr$j &gt;../job-records/thin-geno-norm # pca using thinned snps echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --mem 50G #SBATCH -c 10 #SBATCH -t 6:0:0 ./plink2 --threads 15 \\ --pca approx \\ --bfile ../gen/geno-norm \\ --memory 100000 \\ --extract ../thin/thin-geno-norm.in \\ --keep ../ukbb-recommend.id \\ --out ../gen/pca-337k-ukbb &quot;&gt;sh_script/pca-337k-white-british.sh sbatch -A snpher ../sh_script/pca-337k-white-british.sh &gt;../job-records/pca Here we want to find out the correlation between PC and birth place. east=read.table(&quot;phen/other-traits/east-coord-birth-place.raw.pheno&quot;) north=read.table(&quot;phen/other-traits/north-coord-birth-place.raw.pheno&quot;) id=read.table(&quot;ukbb-recommend.id&quot;) # pcs of 337k recommended individuals pc=read.table(&quot;gen/pca-337k-ukbb.eigenvec&quot;, header=F) # pcs provided by ukbb pc_ukbb=read.table(&quot;phen/PC-10.use&quot;, header=F) m1=match(id$V1,pc$V1) m2=match(id$V1,east$V1) m3=match(id$V1,north$V1) m4=match(id$V1,pc_ukbb$V1) pc_ukbb=pc_ukbb[m4,-1] names(pc_ukbb)=c(&quot;id&quot;, paste0(&quot;pc&quot;,1:10)) dat=data.frame(id=id$V1, east=east$V3[m2], north=north$V3[m3], pc[m1,3:12]) names(dat)[4:13]=paste0(&quot;PC&quot;,1:10) cor(dat$east,dat[,4:13], use=&quot;pair&quot;) cor(dat$north,dat[,4:13], use=&quot;pair&quot;) cor(dat[,4:13],pc_ukbb[,2:11]) # plot pc1 vs. pc2 png(&quot;fig/ukbb-337k-inhouse-pc1-vs-pc2.png&quot;, res=600, width=30, height=20, units=&quot;cm&quot;) par(cex.lab=1.2, font.lab=2, cex.main=1.5) plot(dat$PC1, dat$PC2, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, main=&quot;ukbb 337k unrelated white British&quot;, las=1, cex = 0.8, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) dev.off() # plot pc1 vs. pc2 col-coded by birth location cutoff1=quantile(dat$east, probs = seq(0, 1, 0.1), na.rm=T) dat$bin_east=cut(dat$east, breaks=cutoff1, labels=1:(length(cutoff1)-1)) cutoff2=quantile(dat$north, probs = seq(0, 1, 0.1), na.rm=T) dat$bin_north=cut(dat$north, breaks=cutoff2, labels=1:(length(cutoff2)-1)) require(&quot;RColorBrewer&quot;) pallete1=brewer.pal(10, name=&quot;Spectral&quot;) mycol1=apply(col2rgb(pallete1), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=220)) #pallete2=brewer.pal(10, name=&quot;Purples&quot;) #mycol2=apply(col2rgb(pallete2), 2, # function(X) rgb(X[1], X[2], X[3], max=255, alpha=220)) png(&quot;fig/ukbb-337k-inhouse-pc1-vs-pc2-by-birth-location.png&quot;, res=600, width=40, height=20, units=&quot;cm&quot;) par(mfrow=c(1,2), cex.lab=1.2, font.lab=2, cex.main=1.5) # east plot(NULL, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, xlim=c(min(dat$PC1), max(dat$PC1)), ylim=c(min(dat$PC2), max(dat$PC2)), main=&quot;by east coord bin&quot;, las=1) for(i in 1:10){ sel=dat[dat$bin_east==i &amp; !is.na(dat$bin_east),] points(sel$PC1, sel$PC2, cex = 1.5, pch=21, bg=mycol1[i], col=&quot;white&quot;, lwd=0.5) } # north plot(NULL, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, xlim=c(min(dat$PC1), max(dat$PC1)), ylim=c(min(dat$PC2), max(dat$PC2)), main=&quot;by north coord bin&quot;, las=1) for(i in 1:10){ sel=dat[dat$bin_north==i &amp; !is.na(dat$bin_north),] points(sel$PC1, sel$PC2, cex = 1.5, pch=21, bg=mycol2[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # seperate plots by location bin require(&quot;RColorBrewer&quot;) pallete=brewer.pal(10, name=&quot;Spectral&quot;) mycol=apply(col2rgb(pallete), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=220)) png(&quot;fig/ukbb-337k-inhouse-pc1-vs-pc2-by-east-bin-panel.png&quot;, res=600, width=50, height=20, units=&quot;cm&quot;) par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5) # east for(i in 1:10){ plot(dat$PC1, dat$PC2, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, xlim=c(min(dat$PC1), max(dat$PC1)), ylim=c(min(dat$PC2), max(dat$PC2)), col=rgb(211,211,211,max=255, alpha=150), main=paste0(&quot;east coord bin &quot;, i), las=1) sel=dat[dat$bin_east==i &amp; !is.na(dat$bin_east),] points(sel$PC1, sel$PC2, cex = 1.5, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # north png(&quot;fig/ukbb-337k-inhouse-pc1-vs-pc2-by-north-bin-panel.png&quot;, res=600, width=50, height=20, units=&quot;cm&quot;) par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:10){ plot(dat$PC1, dat$PC2, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, xlim=c(min(dat$PC1), max(dat$PC1)), ylim=c(min(dat$PC2), max(dat$PC2)), col=rgb(211,211,211,max=255, alpha=150), main=paste0(&quot;east coord bin &quot;, i), las=1) sel=dat[dat$bin_north==i &amp; !is.na(dat$bin_north),] points(sel$PC1, sel$PC2, cex = 1.5, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # plot birth location east vs. north east=read.table(&quot;phen/other-traits/east-coord-birth-place.raw.pheno&quot;) north=read.table(&quot;phen/other-traits/north-coord-birth-place.raw.pheno&quot;) id=read.table(&quot;ukbb-recommend.id&quot;) # pcs of 337k recommended individuals pc=read.table(&quot;gen/pca-337k-ukbb.eigenvec&quot;, header=F) # pcs provided by ukbb pc_ukbb=read.table(&quot;phen/PC-10.use&quot;, header=F) m1=match(id$V1,pc$V1) m2=match(id$V1,east$V1) m3=match(id$V1,north$V1) m4=match(id$V1,pc_ukbb$V1) pc_ukbb=pc_ukbb[m4,-1] names(pc_ukbb)=c(&quot;id&quot;, paste0(&quot;pc&quot;,1:10)) dat=data.frame(id=id$V1, east=east$V3[m2], north=north$V3[m3], pc[m1,3:12]) names(dat)[4:13]=paste0(&quot;PC&quot;,1:10) # plot birth location png(&quot;fig/ukbb-337k-birth-location.png&quot;, res=600, width=30, height=20, units=&quot;cm&quot;) par(cex.lab=1.2, font.lab=2, cex.main=1.5, pty=&quot;s&quot;) plot(dat$north, dat$east, xlab=&quot;north coord&quot;, ylab=&quot;east coordinate&quot;, main=&quot;ukbb 337k unrelated white British&quot;, las=1, cex = 0.8, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) dev.off() # plot birth location col-coded by PC1 cutoff1=quantile(dat$PC1, probs = seq(0, 1, 0.1), na.rm=T) dat$bin_PC1=cut(dat$PC1, breaks=cutoff1, labels=1:(length(cutoff1)-1)) cutoff2=quantile(dat$PC2, probs = seq(0, 1, 0.1), na.rm=T) dat$bin_PC2=cut(dat$PC2, breaks=cutoff2, labels=1:(length(cutoff2)-1)) require(&quot;RColorBrewer&quot;) pallete=brewer.pal(10, name=&quot;Spectral&quot;) mycol=apply(col2rgb(pallete), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=150)) png(&quot;fig/ukbb-337k-birth-location-by-pc.png&quot;, res=600, width=40, height=20, units=&quot;cm&quot;) par(mfrow=c(1,2), cex.lab=1.2, font.lab=2, cex.main=1.5,pty=&quot;s&quot;) # PC1 plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=&quot;by PC1 bin&quot;, las=1) for(i in 1:10){ sel=dat[dat$bin_PC1==i &amp; !is.na(dat$bin_PC1),] points(sel$north, sel$east, cex = 0.8, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } # PC2 plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=&quot;by PC2 bin&quot;, las=1) for(i in 1:10){ sel=dat[dat$bin_PC2==i &amp; !is.na(dat$bin_PC2),] points(sel$north, sel$east, cex = 0.8, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # seperate plots ----------------------------------------------------------------- png(&quot;fig/ukbb-337k-birth-location-by-pc1-bin-panel.png&quot;, res=600, width=50, height=20, units=&quot;cm&quot;) par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5, pty=&quot;s&quot;) # PC1 for(i in 1:10){ plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, pch=21, cex=0.5, col=rgb(211,211,211,max=255, alpha=150), xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=paste0(&quot;PC1 bin &quot;, i), las=1) sel=dat[dat$bin_PC1==i &amp; !is.na(dat$bin_PC1),] points(sel$north, sel$east, cex = 1, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # PC2 png(&quot;fig/ukbb-337k-birth-location-by-pc2-bin-panel.png&quot;, res=600, width=50, height=20, units=&quot;cm&quot;) par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:10){ plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, pch=21, cex=0.5, col=rgb(211,211,211,max=255, alpha=150), xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=paste0(&quot;PC2 bin &quot;, i), las=1) sel=dat[dat$bin_PC2==i &amp; !is.na(dat$bin_PC2),] points(sel$north, sel$east, cex = 1, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # seperate plots 5 bins -------------------------------------------------------- # plot birth location col-coded by PC1 cutoff1=quantile(dat$PC1, probs = seq(0, 1, 0.2), na.rm=T) dat$bin_PC1=cut(dat$PC1, breaks=cutoff1, labels=1:(length(cutoff1)-1)) cutoff2=quantile(dat$PC2, probs = seq(0, 1, 0.2), na.rm=T) dat$bin_PC2=cut(dat$PC2, breaks=cutoff2, labels=1:(length(cutoff2)-1)) require(&quot;RColorBrewer&quot;) pallete=brewer.pal(5, name=&quot;Spectral&quot;) mycol=apply(col2rgb(pallete), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=218)) png(&quot;fig/ukbb-337k-birth-location-by-pc1-bin-5panel.png&quot;, res=600, width=50, height=10, units=&quot;cm&quot;) par(mfrow=c(1,5), cex.lab=1.2, font.lab=2, cex.main=1.5, pty=&quot;s&quot;) # PC1 for(i in 1:5){ plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, pch=21, cex=0.5, col=rgb(211,211,211,max=255, alpha=150), xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=paste0(&quot;PC1 bin &quot;, i), las=1) sel=dat[dat$bin_PC1==i &amp; !is.na(dat$bin_PC1),] points(sel$north, sel$east, cex = 1, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() # PC2 png(&quot;fig/ukbb-337k-birth-location-by-pc2-bin-5panel.png&quot;, res=600, width=50, height=10, units=&quot;cm&quot;) par(mfrow=c(1,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:5){ plot(NULL, xlab=&quot;north&quot;, ylab=&quot;east&quot;, pch=21, cex=0.5, col=rgb(211,211,211,max=255, alpha=150), xlim=c(min(dat$north, na.rm=T), max(dat$north, na.rm=T)), ylim=c(min(dat$east, na.rm=T), max(dat$east, na.rm=T)), main=paste0(&quot;PC2 bin &quot;, i), las=1) sel=dat[dat$bin_PC2==i &amp; !is.na(dat$bin_PC2),] points(sel$north, sel$east, cex = 1, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) } dev.off() 18.3 birth place gwas We want to replicate results by Cook et al.Â (2020), where they found that the GWAS for the east and north coordinates of birth place is confounded. Note: Cook used 8.8 M well-imputed SNPs with MAF &gt; 0.5%, but we used 1.1 Hapmap3 SNPs with MAF &gt; 0.01 (this is because ldsc provide ldscores for these SNPs). We want to find out if chisq varies with aver2, and if ldsc intercept indicates inflation. 18.3.1 gwas mkdir birth-place-gwas for i in {east-coord-birth-place,north-coord-birth-place}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 20G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../birth-place-gwas/$i-linear \\ --pheno ../phen/other-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../ukbb-recommend.id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {east-coord-birth-place,north-coord-birth-place}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/gwas-birth-place 18.3.2 chisq ~ aver2 Using our method, we found evidence of confounding in the birth place GWASs. That is, some genetic differences between sub-populations drive the test statistics. This is somewhat surprising for two reasons: 1) using the same aver2 (i.e., for the 337k ukbb white British), our method finds no evidence of confounding for the other 14 traits. 2). genetic variation in birth location was not evident in PCs [no correlation between PCs and coordiantes of birth place]. That is, geographic location of birth place did not systematically vary in genotype data. This suggests that aver2 can pick up fine-scale population structure that is not even evident in the PCs. This suggests that: 1) despite the best efforts of controlling for confounding bias, a post-gwas check for confounding bias is necessary. 2) aver2 can catch subtle systematic genetic variation (i.e., is sensitive to fine-scale population structure), but the fine-scale population structure does not necessarily cause inflation in test statistics (or confound GWAS). # organize data ---------------------------------------------------------------- mkdir birth-place-gwas-out for trait in {east-coord-birth-place,north-coord-birth-place}; do gwas=birth-place-gwas/$trait-linear.summaries aver2=summary/ave-r2-10k-snps-ukbb-norm ldsc=snps-norm.ldscore out=birth-place-gwas-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot require(vroom) traits=c(&quot;east-coord-birth-place&quot;,&quot;north-coord-birth-place&quot;) png(&quot;fig/chisq-aver2-bin-ukbb-recommend-337k-birth-place.png&quot;, res=600, width=20, height=10, units=&quot;cm&quot;) par(mfrow=c(1,2), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;birth-place-gwas-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.3.3 detect inflation using 1kg # combine gwas results with aver2 from 1kg-------------------------------------- for trait in {east-coord-birth-place,north-coord-birth-place}; do gwas=birth-place-gwas/$trait-linear.summaries aver2=ref-1kg/aver2/1kg-ukbb.aver2 tmp=ref-1kg/out/$trait.tmp ldsc=snps-norm.ldscore out=ref-1kg/out/$trait.out awk &#39;BEGIN{print &quot;ukbb_snp ref_snp ref ukbb chisq&quot; } NR==FNR &amp;&amp; NR &gt; 1 {a[$1]; b[$1]=$5; next} {if ($1 in a) print $0, b[$1]}&#39; $gwas $aver2&gt; $tmp awk &#39;BEGIN{print &quot;ukbb_snp ref_snp ref ukbb chisq ldsc&quot; } NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print $0, b[$1]}&#39; $ldsc $tmp &gt; $out done 18.3.4 gwas results Here we use manhattan to check if there is any genome-wide significant results of the birth. # define a plotting function Manhattan=function(var){ # organize data library(vroom) p0=vroom(paste0(&quot;birth-place-gwas/&quot;,var,&quot;-linear.assoc&quot;), col_names=T) p1=p0[p0$Wald_P&lt;=sel &amp; p0$Wald_P!=0 &amp; !is.na(p0$Wald_P),] # only plot &lt;= 0.01 &amp; &gt; 0 p1=p1[order(p1$Chromosome, p1$Basepair, decreasing=F),] # sort data frame # x coordinate based on base pair for(i in 1:22){ maxbp0=data.frame(chr=i,maxbp=max(p1$Basepair[p1$Chromosome==i])) # keep track of maxbp of each chr for later use if(i==1) { cummaxbp=max(p1$Basepair[p1$Chromosome==i]) pos=p1$Basepair[p1$Chromosome==i] maxbp=maxbp0 }else{ pos=c(pos,p1$Basepair[p1$Chromosome==i]+cummaxbp) cummaxbp=cummaxbp+max(p1$Basepair[p1$Chromosome==i]) maxbp=rbind(maxbp, maxbp0) } # add for i &gt; 1, the pos or the x-coordinate of a current snp is the sum # of its basepair &amp; the cumulative max basepair from previous chromosomes. } p2=data.frame(chr=p1$Chromosome, Predictor=p1$Predictor, x=pos, neglog10p=-log10(p1$Wald_P), stringsAsFactors = F) if(sum(p2$neglog10p&gt;=-log10(5*10^-8))&gt;0) sig=p2[p2$neglog10p&gt;=-log10(5*10^-8),] # define objects mycol=rep(c(&quot;darkgray&quot;, &quot;gray&quot;), 11) xtick=c(min(p2$x), cumsum(maxbp$maxbp)) lab.pos=(xtick[1:22]+xtick[2:23])/2 #plotting nm=paste0(&quot;fig/&quot;,var,&quot;-manhattan-plot.png&quot;) png(nm, width=30, height=10, units=&quot;cm&quot;, res=100) plot(NULL, xlab=&quot;chromosome&quot;, ylab=&quot;-log10(p)&quot;, xlim=c(min(p2$x),max(p2$x)), ylim=c(-log10(0.01),-log10(5*10^-8)+2), xaxt=&#39;n&#39;, main=var, bty=&quot;n&quot;, las=2 ) for(i in 1:22){ points(p2$x[p2$chr==i], p2$neglog10p[p2$chr==i], cex = 0.3, pch=16, col=mycol[i]) } abline(h=-log10(5*10^-8), col=&quot;orange&quot;, lty=3) if(sum(p2$neglog10p&gt;=-log10(5*10^-8))&gt;0){ points(sig$x, sig$neglog10p, cex = 0.8, pch=21, bg=&quot;steelblue&quot;, col=&quot;white&quot;, lwd=0.5)} axis(side=1, at=xtick, labels = FALSE) text(x=lab.pos, y= par(&quot;usr&quot;)[3] - 1.5, labels=1:22, xpd=T, cex = 0.8, font=2) dev.off() } # call the function traits=c(&quot;east-coord-birth-place&quot;,&quot;north-coord-birth-place&quot;) cutoff=5*10^-8 sel=0.01 for(i in 1:length(traits)){ Manhattan(traits[i]) } 18.4 GWAS based on PC clusters Here we investigate if fine-scale population structure within unrelated white British (337k) can inflate gwas test statistics. To this end, we performed good &amp; bad GWASs that vary in the heterogeneity of pop. structure, as assessed by PCs (see plot). The good GWAS contains individuals with an average PC1 xx, wheareas the bad GWAS contains individuals with PC1 and PC2 xx. 18.4.1 id lists # k-mean clustering of PC1 &amp; PC2------------------------------------------------ # pcs of 337k recommended individuals pc=read.table(&quot;gen/pca-337k-ukbb.eigenvec&quot;, header=F) names(pc)=c(&quot;eid&quot;, &quot;eid&quot;, paste0(&quot;PC&quot;, 1:10)) pc1pc2=pc[,3:4] set.seed(14) cluster=kmeans(pc1pc2, centers=3, nstart=50) pc$cluster=cluster$cluster centroid=data.frame(PC1=tapply(pc$PC1,INDEX=pc$cluster, mean), PC2=tapply(pc$PC2,INDEX=pc$cluster, mean)) centroid$n=table(pc$cluster) # plot pc1 vs. pc3 by the clusters---------------------------------------------- require(&quot;RColorBrewer&quot;) pallete=brewer.pal(3, name=&quot;Spectral&quot;) mycol=apply(col2rgb(pallete), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=150)) png(&quot;fig/ukbb-337k-inhouse-pc1-vs-pc2.png&quot;, res=600, width=30, height=20, units=&quot;cm&quot;) par(cex.lab=1.2, font.lab=2, cex.main=1.5) plot(NULL, xlab=&quot;1st PC&quot;, ylab=&quot;2nd PC&quot;, xlim=c(min(pc$PC1), max(pc$PC1)), ylim=c(min(pc$PC2), max(pc$PC2)), main=&quot;ukbb 337k unrelated white British&quot;, las=1, cex = 0.8, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) for(i in 1:3){ sel=pc[pc$cluster==i &amp; !is.na(pc$cluster),] points(sel$PC1, sel$PC2, cex = 1, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) # centroid points(centroid[i,1], centroid[i,2], cex = 1.5, pch=21, bg=&quot;steelblue&quot;, col=&quot;white&quot;, lwd=0.5) } dev.off() # plot location by PC clusters-------------------------------------------------- east=read.table(&quot;phen/other-traits/east-coord-birth-place.raw.pheno&quot;) north=read.table(&quot;phen/other-traits/north-coord-birth-place.raw.pheno&quot;) m1=match(pc$eid,east$V1) m2=match(pc$eid,north$V1) pc$east=east$V3[m1] pc$north=north$V3[m2] loc_mean=data.frame(east=tapply(pc$east,INDEX=pc$cluster, function(X) mean(X, na.rm=T)), north=tapply(pc$north,INDEX=pc$cluster, function(X) mean(X, na.rm=T))) require(&quot;RColorBrewer&quot;) pallete=brewer.pal(4, name=&quot;Spectral&quot;) mycol=apply(col2rgb(pallete[c(1,3,4)]), 2, function(X) rgb(X[1], X[2], X[3], max=255, alpha=150)) png(&quot;fig/ukbb-337k-birth-location-by-pc-cluster.png&quot;, res=600, width=30, height=10, units=&quot;cm&quot;) par(mfrow=c(1,3), cex.lab=1.2, font.lab=2, cex.main=1.5, pty=&quot;s&quot;) for(i in 1:3){ plot(NULL, xlim=c(min(pc$north, na.rm=T), max(pc$north, na.rm=T)), ylim=c(min(pc$east, na.rm=T), max(pc$east, na.rm=T)), xlab=&quot;north coord&quot;, ylab=&quot;east coordinate&quot;, main=paste0(&quot;cluster &quot;, i ), las=1, cex = 0.8, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) sel=pc[pc$cluster==i &amp; !is.na(pc$cluster),] points(sel$north, sel$east, cex = 0.8, pch=21, bg=mycol[i], col=&quot;white&quot;, lwd=0.5) # centre points(loc_mean[i,&quot;north&quot;], loc_mean[i,&quot;east&quot;], cex = 1.5, pch=21, bg=&quot;slategrey&quot;, col=&quot;slategrey&quot;, lwd=0.5) } dev.off() # id lists---------------------------------------------------------------------- # cluster 1. c1=100k; # c1a=50k for bad gwas, c1b=50k for control gwas non-overlapping ids. options(scipen = 100) sel=pc$eid[pc$cluster==1] set.seed(4) c1=sample(sel,100000,replace=F) # good gwas: 100k set.seed(14) c1a=sample(c1,50000,replace=F) # for bad gwas: 50k set.seed(114) c1b=sample(sel[!sel%in%c1],50000,replace=F) # for control gwas: 50k # cluster 2 &amp; 3 -&gt; each 1 list = 25k sel=pc$eid[pc$cluster==2] set.seed(5) c2=sample(sel,25000,replace=F) sel=pc$eid[pc$cluster==3] set.seed(56) c3=sample(sel,25000,replace=F) # final list write.table(cbind(c1,c1), &quot;ukbb-recommended-good-gwas.id&quot;, col.names=F, row.names=F, quote=F) write.table(cbind(c(c1a,c2,c3),c(c1a,c2,c3)), &quot;ukbb-recommended-bad-gwas.id&quot;, col.names=F, row.names=F, quote=F) write.table(cbind(c(c1a,c1b),c(c1a,c1b)), &quot;ukbb-recommended-control-gwas.id&quot;, col.names=F, row.names=F, quote=F) 18.4.2 id list for bad gwas2 Here we want to do a GWAS based on the mixture of cluster 1 &amp; cluster 2 only. So that pop structure mostly come from PC1. options(scipen = 100) pc=read.table(&quot;gen/pca-337k-ukbb.eigenvec&quot;, header=F) names(pc)=c(&quot;eid&quot;, &quot;eid&quot;, paste0(&quot;PC&quot;, 1:10)) pc1pc2=pc[,3:4] set.seed(14) cluster=kmeans(pc1pc2, centers=3, nstart=50) centroid=data.frame(PC1=tapply(pc$PC1,INDEX=pc$cluster, mean), PC2=tapply(pc$PC2,INDEX=pc$cluster, mean)) centroid$n=table(pc$cluster) sel=pc$eid[pc$cluster==1] set.seed(4) c1=sample(sel,100000,replace=F) # good gwas: 100k set.seed(14) c1a=sample(c1,50000,replace=F) # for bad gwas: 50k # cluster 2 -&gt; each 1 list = 50k sel=pc$eid[pc$cluster==2] set.seed(5) c2=sample(sel,50000,replace=F) # final list write.table(cbind(c(c1a,c2),c(c1a,c2)), &quot;ukbb-recommended-bad-gwas-2.id&quot;, col.names=F, row.names=F, quote=F) 18.4.3 id list for bad gwas3 Here we use mix individuals of the bottom and top PC1 only without considering PC2. options(scipen = 100) pc=read.table(&quot;gen/pca-337k-ukbb.eigenvec&quot;, header=F) names(pc)=c(&quot;eid&quot;, &quot;eid&quot;, paste0(&quot;PC&quot;, 1:10)) dat=pc[order(pc$PC1),] out=rbind(dat[1:50000,1:2], dat[(dim(dat)[1]-50000+1):dim(dat)[1],1:2]) # final list write.table(out, &quot;ukbb-recommended-bad-gwas-3.id&quot;, col.names=F, row.names=F, quote=F) 18.4.4 bad gwas mkdir fine-scale-pop-struct mkdir fine-scale-pop-struct/bad-gwas dir=fine-scale-pop-struct/bad-gwas for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../$dir/$i-linear \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../ukbb-recommended-bad-gwas.id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/basic-covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/bad-gwas-fine-scale 18.4.5 bad gwas#2 For mixing cluster 1 &amp; cluster 2 only. mkdir fine-scale-pop-struct/bad-gwas-2 dir=fine-scale-pop-struct/bad-gwas-2 id=ukbb-recommended-bad-gwas-2.id for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../$dir/$i-linear \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../$id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/basic-covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/bad-gwas-2-fine-scale 18.4.6 bad gwas#3 mkdir fine-scale-pop-struct/bad-gwas-3 dir=fine-scale-pop-struct/bad-gwas-3 id=ukbb-recommended-bad-gwas-3.id for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../$dir/$i-linear \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../$id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/basic-covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/bad-gwas-3-fine-scale 18.4.7 good gwas mkdir fine-scale-pop-struct/good-gwas dir=fine-scale-pop-struct/good-gwas id=ukbb-recommended-good-gwas.id for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../$dir/$i-linear \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../$id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/good-gwas-fine-scale 18.4.8 control gwas mkdir fine-scale-pop-struct/control-gwas dir=fine-scale-pop-struct/control-gwas id=ukbb-recommended-control-gwas.id for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 8G #SBATCH -c 3 #SBATCH -t 10:0:0 ./ldak5.1 --linear ../$dir/$i-linear \\ --pheno ../phen/continuous-traits/$i.raw.pheno \\ --bfile ../gen/geno-norm \\ --keep ../$id \\ --extract ../gen/snps-norm.use \\ --covar ../phen/covariates.use \\ --max-threads 3 \\ &quot;&gt; sh_script/$i-linear.sh done # submit files for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do sbatch -A snpher ../sh_script/$i-linear.sh done&gt;../job-records/control-gwas-fine-scale 18.5 compute aver2 18.5.1 bad-gwas # new directory mkdir inflation/fine-scale-pop-struct/bad-gwas # to calc aver2 for lista------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas/aver2-lista echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-aver2-lista # job submission sbatch -A snpher ../sh_script/calc-aver2-lista &gt;../job-records/calc-aver2-fine-pop-bad-gwas # to calc aver2 for listb------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas/aver2-listb echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $listb \\ --listb $lista &quot;&gt;sh_script/calc-aver2-listb # job submission sbatch -A snpher ../sh_script/calc-aver2-listb &gt;../job-records/calc-aver2-fine-pop-bad-gwas # merge aver2 of the two lists-------------------------------------------------- dir=inflation/fine-scale-pop-struct/bad-gwas a=$dir/aver2-lista.rjk2.average b=$dir/aver2-listb.rjk2.average out=$dir/bad-gwas.aver2 awk &#39;FNR &gt; 1 {print $1, $2}&#39; $a $b &gt; $out 18.5.2 bad-gwas#2 # new directory mkdir inflation/fine-scale-pop-struct/bad-gwas-2 # to calc aver2 for lista------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas-2.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas-2/aver2-lista echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-aver2-lista # job submission sbatch -A snpher ../sh_script/calc-aver2-lista &gt;../job-records/calc-aver2-fine-pop-bad-gwas-2 # to calc aver2 for listb------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas-2.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas-2/aver2-listb echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $listb \\ --listb $lista &quot;&gt;sh_script/calc-aver2-listb # job submission sbatch -A snpher ../sh_script/calc-aver2-listb &gt;../job-records/calc-aver2-fine-pop-bad-gwas-2 # merge aver2 of the two lists-------------------------------------------------- dir=inflation/fine-scale-pop-struct/bad-gwas-2 a=$dir/aver2-lista.rjk2.average b=$dir/aver2-listb.rjk2.average out=$dir/bad-gwas-2.aver2 awk &#39;FNR &gt; 1 {print $1, $2}&#39; $a $b &gt; $out 18.5.3 bad-gwas#3 # new directory mkdir inflation/fine-scale-pop-struct/bad-gwas-3 # to calc aver2 for lista------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas-3.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas-3/aver2-lista echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-aver2-lista # job submission sbatch -A snpher ../sh_script/calc-aver2-lista &gt;../job-records/calc-aver2-fine-pop-bad-gwas-3 # to calc aver2 for listb------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-bad-gwas-3.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/bad-gwas-3/aver2-listb echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $listb \\ --listb $lista &quot;&gt;sh_script/calc-aver2-listb # job submission sbatch -A snpher ../sh_script/calc-aver2-listb &gt;../job-records/calc-aver2-fine-pop-bad-gwas-3 # merge aver2 of the two lists-------------------------------------------------- dir=inflation/fine-scale-pop-struct/bad-gwas-3 a=$dir/aver2-lista.rjk2.average b=$dir/aver2-listb.rjk2.average out=$dir/bad-gwas-3.aver2 awk &#39;FNR &gt; 1 {print $1, $2}&#39; $a $b &gt; $out 18.5.4 good-gwas # new directory mkdir inflation/fine-scale-pop-struct/good-gwas # to calc aver2 for lista------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-good-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/good-gwas/aver2-lista echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-aver2-lista # job submission sbatch -A snpher ../sh_script/calc-aver2-lista &gt;../job-records/calc-aver2-fine-pop-good-gwas # to calc aver2 for listb------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-good-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/good-gwas/aver2-listb echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $listb \\ --listb $lista &quot;&gt;sh_script/calc-aver2-listb # job submission sbatch -A snpher ../sh_script/calc-aver2-listb &gt;../job-records/calc-aver2-fine-pop-good-gwas # merge aver2 of the two lists-------------------------------------------------- dir=inflation/fine-scale-pop-struct/good-gwas a=$dir/aver2-lista.rjk2.average b=$dir/aver2-listb.rjk2.average out=$dir/good-gwas.aver2 awk &#39;FNR &gt; 1 {print $1, $2}&#39; $a $b &gt; $out 18.5.5 control-gwas # new directory mkdir inflation/fine-scale-pop-struct/control-gwas # to calc aver2 for lista------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-control-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/control-gwas/aver2-lista echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $lista \\ --listb $listb &quot;&gt;sh_script/calc-aver2-lista # job submission sbatch -A snpher ../sh_script/calc-aver2-lista &gt;../job-records/calc-aver2-fine-pop-control-gwas # to calc aver2 for listb------------------------------------------------------- lista=../inflation/left-snps-unrel-inds-10k listb=../inflation/right-snps-unrel-inds-10k id=../ukbb-recommended-control-gwas.id bfile=../gen/geno-norm out=../inflation/fine-scale-pop-struct/control-gwas/aver2-listb echo &quot;#&quot;&#39;!&#39;&quot;/bin/bash #SBATCH --constraint \\&quot;s04|s05\\&quot; #SBATCH --partition normal #SBATCH --mem 30G #SBATCH -c 7 #SBATCH -t 00:40:0 ./ldak5.2 --max-threads 7 \\ --calc-inflation $out \\ --keep $id \\ --bfile $bfile \\ --lista $listb \\ --listb $lista &quot;&gt;sh_script/calc-aver2-listb # job submission sbatch -A snpher ../sh_script/calc-aver2-listb &gt;../job-records/calc-aver2-fine-pop-control-gwas # merge aver2 of the two lists-------------------------------------------------- dir=inflation/fine-scale-pop-struct/control-gwas a=$dir/aver2-lista.rjk2.average b=$dir/aver2-listb.rjk2.average out=$dir/control-gwas.aver2 awk &#39;FNR &gt; 1 {print $1, $2}&#39; $a $b &gt; $out 18.6 chisq ~ aver2 18.6.1 bad gwas # organize information---------------------------------------------------------- mkdir fine-scale-pop-struct/bad-gwas-out for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do gwas=fine-scale-pop-struct/bad-gwas/$trait-linear.summaries aver2=inflation/fine-scale-pop-struct/bad-gwas/bad-gwas.aver2 ldsc=snps-norm.ldscore out=fine-scale-pop-struct/bad-gwas-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot chisq ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/chisq-aver2-bin-fine-pop-bad-gwas.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/bad-gwas-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.6.2 bad gwas#2 # organize information---------------------------------------------------------- mkdir fine-scale-pop-struct/bad-gwas-2-out for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do gwas=fine-scale-pop-struct/bad-gwas-2/$trait-linear.summaries aver2=inflation/fine-scale-pop-struct/bad-gwas-2/bad-gwas-2.aver2 ldsc=snps-norm.ldscore out=fine-scale-pop-struct/bad-gwas-2-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot chisq ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/chisq-aver2-bin-fine-pop-bad-gwas-2.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/bad-gwas-2-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.6.3 bad gwas#3 # organize information---------------------------------------------------------- mkdir fine-scale-pop-struct/bad-gwas-3-out for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do gwas=fine-scale-pop-struct/bad-gwas-3/$trait-linear.summaries aver2=inflation/fine-scale-pop-struct/bad-gwas-3/bad-gwas-3.aver2 ldsc=snps-norm.ldscore out=fine-scale-pop-struct/bad-gwas-3-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot chisq ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/chisq-aver2-bin-fine-pop-bad-gwas-3.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/bad-gwas-3-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.6.4 good gwas # organize information---------------------------------------------------------- mkdir fine-scale-pop-struct/good-gwas-out for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do gwas=fine-scale-pop-struct/good-gwas/$trait-linear.summaries aver2=inflation/fine-scale-pop-struct/good-gwas/good-gwas.aver2 ldsc=snps-norm.ldscore out=fine-scale-pop-struct/good-gwas-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot chisq ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/chisq-aver2-bin-fine-pop-good-gwas.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/good-gwas-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.6.5 control gwas # organize information---------------------------------------------------------- mkdir fine-scale-pop-struct/control-gwas-out for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do gwas=fine-scale-pop-struct/control-gwas/$trait-linear.summaries aver2=inflation/fine-scale-pop-struct/control-gwas/control-gwas.aver2 ldsc=snps-norm.ldscore out=fine-scale-pop-struct/control-gwas-out/$trait.out awk &#39;NR&gt;1 {print $1, $5}&#39; $gwas &gt; tmp/gwas.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $ldsc tmp/gwas.tmp &gt; tmp/ldsc.tmp awk &#39;NR==FNR {a[$1]; b[$1]=$2; next} {if ($1 in a) print b[$1]; else print &quot;NA&quot; }&#39; $aver2 tmp/gwas.tmp &gt; tmp/aver2.tmp # put info together paste tmp/gwas.tmp \\ tmp/aver2.tmp \\ tmp/ldsc.tmp \\ | awk &#39;BEGIN{OFS=&quot;;&quot; ; print &quot;snp;chisq;aver2;ldsc&quot;} {$1=$1}1&#39; &gt; $out done # plot chisq ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/chisq-aver2-bin-fine-pop-control-gwas.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/control-gwas-out/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(chisq ~ aver2 + ldsc,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$chisq_ave) # plot plot(out$bin_val, out$chisq_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean chisq&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(chisq ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() 18.7 inflation ~ aver2 In the above, we showed that bad GWAS that mixes individuals of bottom 50k and top 50k based on PC1 is confounded. Here we want to show that the inflation varies with respect to aver2. # organize data mkdir fine-scale-pop-struct/inflation-good-dad-gwas-3 for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do good=fine-scale-pop-struct/good-gwas-out/$trait.out bad=fine-scale-pop-struct/bad-gwas-3-out/$trait.out out=fine-scale-pop-struct/inflation-good-dad-gwas-3/$trait.out awk -F&#39;;&#39; &#39;BEGIN{print&quot;snp inflation aver2 ldsc&quot;} (NR==FNR &amp;&amp; NR&gt;1) {a[$1]; b[$1]=$2; next} (NR&gt;1){if ($1 in a) print $1, $2-b[$1], $3, $4}&#39; $good $bad &gt; $out done # plot inflation ~ aver2------------------------------------------------------------ require(vroom) traits=c(&quot;awake&quot;,&quot;bmi&quot;,&quot;chron&quot;,&quot;ever&quot;, &quot;neur&quot;,&quot;pulse&quot;,&quot;quals&quot;, &quot;fvc&quot;, &quot;height&quot;,&quot;imp&quot;, &quot;reaction&quot;,&quot;sbp&quot;,&quot;snoring&quot;,&quot;hyper&quot;) png(&quot;fig/inflation-aver2-bin-fine-pop-good-bad-gwas-3.png&quot;, res=600, width=50, height=30, units=&quot;cm&quot;) par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5) for(i in 1:length(traits)){ trait=traits[i] dat=vroom(paste0(&quot;fine-scale-pop-struct/inflation-good-dad-gwas-3/&quot;,trait,&quot;.out&quot;), col_names=T) dat=dat[complete.cases(dat),] # linear model mod=lm(inflation ~ aver2 ,data=dat) p=summary(mod)$coefficients[,4][2] p_sci=formatC(p, format=&quot;e&quot;, digit=2) # bin a variable by quantile cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T) dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1)) # average chisq by bin values out=data.frame(inflation_ave=tapply(dat$inflation,INDEX=dat$bin, mean)) out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean) px=min(out$bin_val) py=max(out$inflation_ave) # plot plot(out$bin_val, out$inflation_ave, xlab=&quot;ave r2 bin&quot;, ylab=&quot;mean inflation&quot;, main=trait, las=1, cex = 1.5, pch=21, bg=&quot;darkgray&quot;, col=&quot;white&quot;, lwd=0.5) abline(lm(inflation ~ aver2,data=dat),col=&quot;orange&quot;, lwd=2) if(p&lt;0.01){text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), col=&quot;red&quot;, cex=2, font=2) } else {text(px, py, paste0(&quot;p = &quot;, p_sci), adj=c(0,1), cex=2, font=2)} } dev.off() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
