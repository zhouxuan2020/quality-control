
# Bad GWAS {#bad}

## ID list {#badid}

### initial selection
Randomly select participants with complete data and use the SNP list as for unrelated.

```{bash eval=F}

# extract white, asian & black from ukbb----------------------------------------
R
dat=read.table("phen/covariates.phen", header=T, stringsAsFactors = F)
# White: British(1001)  
# Asian or Asian British: Indian(3001)+Pakistani(3002)+Bangladeshi(3003)+other Asian backgroud(3004)
# Black: Caribbean(4001)+African(4002)+other Black Background(4003)
dat=dat[complete.cases(dat),]
white=1001
asian=3001:3004
black=4001:4003
out1=dat[dat$ethnicity%in%white,]
out2=dat[dat$ethnicity%in%asian,]
out3=dat[dat$ethnicity%in%black,]
write.table(out1[,"eid"], "white-complete-cov.id", col.names=F, row.names=F, quote=F)
write.table(out2[,"eid"], "asian-complete-cov.id", col.names=F, row.names=F, quote=F)
write.table(out3[,"eid"], "black-complete-cov.id", col.names=F, row.names=F, quote=F)
# overlapping UNRELATED WHITE across 14 traits----------------------------------
# overlapping = no missing data for the 14 traits

cp icd10/unrelated.inds overlap.ind # unrelated white British

dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap.ind temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap.ind
wc -l overlap.ind
echo $tt
done
rm temp

# overlapping + complete data for covariates + unrelated
awk 'NR==FNR{a[$1]; next} ($1 in a) {print $1, $1}' unrelated/overlap.ind white-complete-cov.id > overlap-white-complete-cov.id # N = 147,008

# overlapping UNRELATED ASIAN across 14 traits----------------------------------
cp asian-complete-cov.id overlap-asian-complete-cov.id
dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap-asian-complete-cov.id temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap-asian-complete-cov.id
wc -l overlap-asian-complete-cov.id # N = 4,052
echo $tt
done
rm temp

# relatedness filtering
# see below

# overlapping UNRELATED BLACK across 14 traits----------------------------------
cp black-complete-cov.id overlap-black-complete-cov.id
dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap-black-complete-cov.id temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap-black-complete-cov.id
wc -l overlap-black-complete-cov.id # N = 3,583
echo $tt
done
rm temp

# relatedness filtering
# see below

```

### relatedness filtering

For black and Asian people only.

```{bash eval=F}
#-------------
# 0. make bfiles
#------------

# id lists
overlap-white-complete-cov.id # N=147,008
overlap-black-complete-cov.id # N=3,583
overlap-asian-complete-cov.id # N=4,052
awk '{print $0}' overlap-white-complete-cov.id overlap-black-complete-cov.id overlap-asian-complete-cov.id > overlap-mixed-complete-cov.id # 154,643    

# bfiles by chr
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../overlap-mixed-complete-cov.id \
         --extract ../gen/snps-unrel-inds.use \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-mix \
         --threads 3 \
"> sh_script/chr$j-mix.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i-mix.sh
done>../job-records/mkbfile-mix-pop

# merge bfiles
rm bfile-mix.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-mix" >>bfile-mix.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 10:0:0
./ldak5.1 --make-bed ../gen/geno-mix \
          --mbfile ../gen/bfile-mix.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/merge-mbfiles-mix-pop.sh

# submit the script
sbatch -A snpher ../sh_script/merge-mbfiles-mix-pop.sh >../job-records/merge-mbfiles-mix

#-------
# 1. prune SNPs
#-------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 4
#SBATCH -t 5:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --max-threads 4 \
          --window-prune 0.05 \
          --window-kb 1000 \
          --bfile ../gen/geno-mix \
          --chr $j \
          --thin ../thin/thin-chr$j
"  > sh_script/thin$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/thin$j
done > ../job-records/thin-snps

#-------------
# 2. kinship matrix under GCTA
#-------------

for pop in {black,asian}; do
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 3 \
          --calc-kins-direct ../kinship/$pop-gcta-thin$j \
          --bfile ../gen/geno-mix \
          --keep ../overlap-$pop-complete-cov.id\
          --extract ../thin/thin-chr$j.in \
          --chr $j \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/$pop-grm$j
done
done

# submit files
for pop in {black,asian}; do 
for j in {1..22}; do
sbatch -A snpher ../sh_script/$pop-grm$j
done
done > ../job-records/grm-pops

# merge grms
for pop in {black,asian}; do
rm $pop-grm.list
for j in {1..22} 
do 
echo "../kinship/$pop-gcta-thin$j" >> $pop-grm.list
done
done

for pop in {black,asian}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 80G
#SBATCH -c 10
#SBATCH -t 12:0:0
./ldak5.1 --add-grm ../kinship/$pop-gcta-thin --mgrm ../$pop-grm.list
"> sh_script/$pop-grm.sh
done

for pop in {black,asian}; do
sbatch -A snpher ../sh_script/$pop-grm.sh 
done > ../job-records/grm-merge

#can now delete per-chr files
#rm *gcta-thin{1..22}.*

#-----------------------
# 3. Relatedness filtering 
#------------------------

# relatedness filtering
for pop in {asian,black};do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 2:0:0

./ldak5.1 --filter ../relatedness/$pop-cut.05 \
          --grm ../kinship/$pop-gcta-thin \
          --max-rel 0.05 \
          --max-threads 3
"> sh_script/$pop-rel-cut.05.sh
done

# submit script
for pop in {asian,black};do
sbatch -A snpher ../sh_script/$pop-rel-cut.05.sh
done > ../job-records/relatedness-filtering

# remaining individuals
# asian-cut.05.keep N = 3,448
# black-cut.05.keep N = 3,024
# sum = 6,472
```

### final list

To match the good GWAS, we will have N = 100k in total and replace 6,472 whites with Asians and Blacks.

```{bash eval=F}
# select  
shuf rand.100000 | head -n 93528 > white.rand.93528
cat white.rand.93528 relatedness/asian-cut.05.keep relatedness/black-cut.05.keep > mix-pop-gwas.id 

```

## GWAS

We use basic covariates only: age, sex and townsend

```{bash eval=F}
# covariates
awk '{print $1, $2, $3, $4, $5}' covariates.use > basic-covariates.use
awk 'NR<=5{print $0}' covariates.use-names > basic-covariates.use

# gwas
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --linear ../gwas-mix/$i-linear-chr-$j \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-mix \
          --covar ../phen/basic-covariates.use \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/snps-unrel-inds.use \
          --max-threads 2 \
          --chr $j
"> sh_script/$i-linear-chr-$j.sh
done
done
# --covar ../phen/covariates.use

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
sbatch -A snpher ../sh_script/$i-linear-chr-$j.sh
done
done>../job-records/gwas-mix-pop

# check job completion----------------------------------------------------------
file=job-records/gwas-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# combine results
# only need .summaries & .pvalues
for i in {awake,bmi,quals,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper}; do 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-chr-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-chr-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-chr-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-chr-$j.pvalues >> $i-linear.pvalues
fi
done
done

```

## ldsc intercept

### under gcta
```{bash eval=F}
#:::::::::::::
# using original ldsc
#:::::::::::::

# format stats for ldsc--------------------------------------------------------- 
library(vroom)
options(scipen = 100)
rs=vroom("doug/ukbb.ldsc", col_names=F)
phen=c("awake","bmi","chron","ever","fvc",
       "height","imp","neur","pulse","quals",
       "reaction","sbp","snoring","hyper", "quals")

for(i in phen){
  stat=vroom(paste0("gwas-mix/",i,"-linear.summaries"), col_names=T)
  p=vroom(paste0("gwas-mix/",i,"-linear.pvalues"), col_names=T)
  m1=match(rs$X1, stat$Predictor)
  m2=match(rs$X1, p$Predictor)
  out=data.frame(SNP=rs$X2,
                 N=stat$n[m1],
                 Z=(sqrt(stat$Stat)*stat$Direction)[m1],
                 A1=stat$A1[m1],
                 A2=stat$A2[m1], 
                 pval=p$P[m2], stringsAsFactors=F)
  out=out[complete.cases(out),]
  write.table(out, paste0("gwas-mix/",i,"-linear-rs.summaries"), 
  col.names=T, row.names=F, quote=F)
}

# perform ldsc------------------------------------------------------------------
mkdir out-mix-pop
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 3
#SBATCH -t 08:00:0

.././munge_sumstats.py \
--sumstats ../../gwas-mix/$i-linear-rs.summaries \
--out ../out-mix-pop/$i \
--merge-alleles ../w_hm3.snplist

.././ldsc.py \
--h2 ../out-mix-pop/$i.sumstats.gz \
--ref-ld-chr ../eur_w_ld_chr/ \
--w-ld-chr ../eur_w_ld_chr/ \
--out ../out-mix-pop/$i-ldsc
">sh_script/ldsc-$i-mix-pop.sh
done

# submit jobs-------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper,quals}; do
sbatch -A snpher ../sh_script/ldsc-$i-mix-pop.sh
done>../../job-records/ldsc-mix-pop

# check job completion----------------------------------------------------------
file=job-records/ldsc-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::::::::::
# using sumher
#:::::::::::::

# insert genetic distance into bim file-----------------------------------------
# here we want to use the same genetic distance as for unrelated individuals, i.e., good GWAS
R
dat=read.table("gen/geno-mix.bim", header=F, stringsAsFactors=F)
ref=read.table("gen/geno-unrel.bim", header=F, stringsAsFactors=F)
m=match(dat$V2,ref$V2)
out=data.frame(dat$V1, dat$V2, ref$V3[m], dat$V4, dat$V5, dat$V6, stringsAsFactors=F)
write.table(out,"gen/geno-mix.bim2", col.names=F, row.names=F, quote=F)

mv geno-mix.bim geno-mix.bim0
mv geno-mix.bim2 geno-mix.bim

# compute tagging under gcta----------------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --calc-tagging ../tagging-mix-pop/gcta-hapmap3-chr-$j \
          --bfile ../gen/geno-mix \
          --ignore-weights YES \
          --power -1 \
          --window-cm 1 \
          --chr $j
"> sh_script/tagging-gcta-hapmap3-chr$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-gcta-hapmap3-chr$j 
done > ../job-records/tagging-gcta-hadmap3-mix-pop

# check job completion----------------------------------------------------------
file=job-records/tagging-gcta-hadmap3-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
for j in {1..22}; do 
echo "tagging-mix-pop/gcta-hapmap3-chr-$j.tagging" >> list.txt
done
./ldak5.1 --join-tagging tagging-mix-pop/gcta-hapmap3 --taglist list.txt

# ldsc intercept----------------------------------------------------------------
mkdir sumher-mix
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --sum-hers ../sumher-mix/$i-sumher-gcta \
          --tagfile ../tagging-mix-pop/gcta-hapmap3.tagging \
          --summary ../gwas-mix/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-gcta-mix-pop
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-gcta-mix-pop
done>../job-records/sumher-gcta-mix-pop

# check job completion----------------------------------------------------------
file=job-records/sumher-gcta-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### under ldak-thin

```{bash eval=F}
# get weights-------------------------------------------------------------------
awk < ldak-thin/ldak-thin-hapmap3.in '{print $1, 1}' > ldak-thin/weights.ldak-thin-hapmap3

# calculate tagging under ldak-thin---------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 40G
#SBATCH -c 5
#SBATCH -t 10:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --calc-tagging ../tagging-mix-pop/ldak-thin-hapmap3-chr-$j \
          --bfile ../gen/geno-mix \
          --weights ../ldak-thin/weights.ldak-thin-hapmap3 \
          --power -.25 \
          --window-cm 1 \
          --chr $j \
          --save-matrix YES \
          --max-threads 5
" > sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done

# submit scripts
for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done > ../job-records/tagging-ldak-thin-hapmap3

# check job completion----------------------------------------------------------
file=job-records/tagging-ldak-thin-hapmap3
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
rm matlist.txt
for j in {1..22}; do 
echo "tagging-mix-pop/ldak-thin-hapmap3-chr-$j.tagging" >> list.txt
echo "tagging-mix-pop/ldak-thin-hapmap3-chr-$j.matrix" >> matlist.txt
done
./ldak5.1 --join-tagging tagging-mix-pop/ldak-thin-hapmap3 --taglist list.txt --matlist matlist.txt

# ldsc intercept----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --sum-hers ../sumher-mix/$i-sumher-ldak-thin \
          --tagfile ../tagging-mix-pop/ldak-thin-hapmap3.tagging \
          --summary ../gwas-mix/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-ldak-thin-mix
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-ldak-thin-mix
done>../job-records/sumher-ldak-thin-mix

# check job-completion
file=job-records/sumher-ldak-thin-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### summary

```{bash eval=F}

# without 40 PCs----------------------------------------------------------------------
# original ldsc
grep Intercept *ldsc.log | awk '{split($1, a, /[-]/); split($3, b, /[()]/); print a[1], $2, b[2]}' > ../../summary/ldsc-mix

# sumher under gcta
grep Intercept_Estimate *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-est
grep Intercept_SD *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-sd
cd ../summary/
paste sumher-gcta-mix-est sumher-gcta-mix-sd | awk '{print $1, $2, $4}' > sumher-gcta-mix
rm sumher-gcta-mix-sd sumher-gcta-mix-est
      
# suhmer under ldak-thin
grep Intercept_Estimate *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-est
grep Intercept_SD *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-sd
cd ../summary/
paste sumher-ldak-thin-mix-est sumher-ldak-thin-mix-sd | awk '{print $1, $2, $4}' > sumher-ldak-thin-mix
rm sumher-ldak-thin-mix-sd sumher-ldak-thin-mix-est

# with covariates (i.e., including all 40 PCs)-------------------------------------------

# original ldsc
grep Intercept *ldsc.log | awk '{split($1, a, /[-]/); split($3, b, /[()]/); print a[1], $2, b[2]}' > ../../summary/ldsc-mix-with-cov

# sumher under gcta
grep Intercept_Estimate *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-est
grep Intercept_SD *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-sd
cd ../summary/
paste sumher-gcta-mix-est sumher-gcta-mix-sd | awk '{print $1, $2, $4}' > sumher-gcta-mix-with-cov
rm sumher-gcta-mix-sd sumher-gcta-mix-est
      
# suhmer under ldak-thin
grep Intercept_Estimate *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-est
grep Intercept_SD *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-sd
cd ../summary/
paste sumher-ldak-thin-mix-est sumher-ldak-thin-mix-sd | awk '{print $1, $2, $4}' > sumher-ldak-thin-mix-with-cov
rm sumher-ldak-thin-mix-sd sumher-ldak-thin-mix-est

```

## REML
### making grms
```{bash eval=F}
# making grm -------------------------------------------------------------------

#:::
# under gcta
#:::

# all snps
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 120G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-all-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-all-snps-mix

sbatch -A snpher ../sh_script/grm-all-snps-mix > ../job-records/grm-all-snps-mix

# grm by snp blocks: right vs. left
awk '$1<8 {print $2}' geno-mix.bim > left-mix-pop.snps 
awk '$1>=8 {print $2}' geno-mix.bim > right-mix-pop.snps

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-$i-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/$i-mix-pop.snps \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-gcta-$i-mix
done

for i in left right; do
sbatch -A snpher ../sh_script/grm-gcta-$i-mix 
done > ../job-records/grm-gcta-by-snps-mix

# check job completion----------------------------------------------------------
file=job-records/grm-gcta-by-snps-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::
# under ldak-thin
#:::

#-----------
# 1. thin snps
#-----------
# we omit this step and use ldak-thin/ldak-thin-hapmap3.in, which was created previously
# using geno-unrel bfiles. See above.

#----------------------
# 2. kinship matrix under ldak-thin
#------------------------

echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-all-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../ldak-thin/ldak-thin-hapmap3.in \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-all-snps-mix

sbatch -A snpher ../sh_script/ldak-thin-grm-all-snps-mix> ../job-records/ldak-thin-grm-all-snps-mix

# grm by snp blocks: right vs. left

awk '{split($1, a, /[:]/); if (a[1]<8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/left-ldak-thin-hapmap3.snps 
awk '{split($1, a, /[:]/); if (a[1]>=8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/right-ldak-thin-hapmap3.snps 

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-$i-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/$i-ldak-thin-hapmap3.snps \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-$i-mix
done

for i in left right; do
sbatch -A snpher ../sh_script/ldak-thin-grm-$i-mix 
done > ../job-records/grm-ldak-thin-by-snps-mix

# check job completion----------------------------------------------------------
file=job-records/grm-ldak-thin-by-snps-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### fast-reml
```{bash eval=F}

#:::
# under gcta
#:::

# make script files-------------------------------------------------------------
mkdir reml-mix
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-mix/$i-gcta-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --covar ../phen/basic-covariates.use \
          --grm ../kinship/gcta-$k-mix \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-mix-gcta-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-mix-gcta-$k-snps
done
done>../job-records/reml-mix-gcta

# check job completion----------------------------------------------------------
file=job-records/reml-mix-gcta
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# cancel jobs 
for i in {1..14}; do
job=`awk -v i=$i 'NR==i{print $0}' kill-jobs`
scancel $job
done

#:::
# under ldak-thin
#:::

# make script files-------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-mix/$i-ldak-thin-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --covar ../phen/basic-covariates.use \
          --grm ../kinship/ldak-thin-$k-mix \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-mix-ldak-thin-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-mix-ldak-thin-$k-snps
done
done >../job-records/reml-mix-ldak-thin

# check job completion----------------------------------------------------------
file=job-records/reml-mix-ldak-thin
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### inflation test

```{bash eval=F}
#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/reml-gcta-mix.all"), header=T)
left=read.table(paste0("summary/reml-gcta-mix.left"), header=T)
right=read.table(paste0("summary/reml-gcta-mix.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/reml-gcta-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R
full=read.table(paste0("summary/reml-ldak-thin-mix.all"), header=T)
left=read.table(paste0("summary/reml-ldak-thin-mix.left"), header=T)
right=read.table(paste0("summary/reml-ldak-thin-mix.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}

write.table(out, paste0("summary/reml-ldak-thin-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

```


## HE

### estimation 

```{bash eval=F}
# regress grm on covariates-----------------------------------------------------

for grm in gcta-all-mix gcta-left-mix gcta-right-mix ldak-thin-all-mix ldak-thin-left-mix ldak-thin-right-mix; do  
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 50G
#SBATCH -c 5
#SBATCH -t 10:0:0
./ldak5.1 --adjust-grm ../kinship/$grm.covar \
          --grm ../kinship/$grm \
          --covar ../phen/basic-covariates.use \
          --max-threads 5
"> sh_script/$grm-adjust.sh
done

# submit jobs
for grm in gcta-all-mix gcta-left-mix gcta-right-mix ldak-thin-all-mix ldak-thin-left-mix ldak-thin-right-mix; do
sbatch -A snpher ../sh_script/$grm-adjust.sh
done > ../job-records/grm-adjust-for-HE

# check job completion----------------------------------------------------------
file=job-records/grm-adjust-for-HE
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# HE under gcta-----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --he ../he-mix/$i-he-gcta-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/gcta-$k-mix.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/basic-covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-gcta-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-gcta-$k-snps.sh
done
done > ../job-records/he-gcta

# HE under ldak-thin------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 0:30:0

./ldak5.1 --he ../he-mix/$i-he-ldak-thin-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/ldak-thin-$k-mix.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/basic-covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-ldak-thin-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-ldak-thin-$k-snps.sh
done
done > ../job-records/he-ldak-thin

```

### summary

```{bash eval=F}

#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-gcta-mix.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.right
done

# left
rm summary/he-gcta-mix.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.left
done

# all
rm summary/he-gcta-mix.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-gcta-mix.all"), header=F)
left=read.table(paste0("summary/he-gcta-mix.left"), header=F)
right=read.table(paste0("summary/he-gcta-mix.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-gcta-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)


#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-ldak-thin-mix.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-ldak-thin-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.right
done

# left
rm summary/he-ldak-thin-mix.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-ldak-thin-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.left
done

# all
rm summary/he-ldak-thin-mix.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-ldak-thin-mix.all"), header=F)
left=read.table(paste0("summary/he-ldak-thin-mix.left"), header=F)
right=read.table(paste0("summary/he-ldak-thin-mix.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-ldak-thin-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

```


