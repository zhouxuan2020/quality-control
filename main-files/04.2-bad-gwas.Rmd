
# Bad GWAS {#bad}

## ID list {#badid}

### initial selection

Randomly select participants with complete data and use the SNP list as for unrelated.

```{bash eval=F}

# extract white, asian & black from ukbb----------------------------------------
R
dat=read.table("phen/covariates.phen", header=T, stringsAsFactors = F)
# White: British(1001)  
# Asian or Asian British: Indian(3001)+Pakistani(3002)+Bangladeshi(3003)+other Asian backgroud(3004)
# Black: Caribbean(4001)+African(4002)+other Black Background(4003)
dat=dat[complete.cases(dat),]
white=1001
asian=3001:3004
black=4001:4003
out1=dat[dat$ethnicity%in%white,]
out2=dat[dat$ethnicity%in%asian,]
out3=dat[dat$ethnicity%in%black,]
write.table(out1[,"eid"], "white-complete-cov.id", col.names=F, row.names=F, quote=F)
write.table(out2[,"eid"], "asian-complete-cov.id", col.names=F, row.names=F, quote=F)
write.table(out3[,"eid"], "black-complete-cov.id", col.names=F, row.names=F, quote=F)
# overlapping UNRELATED WHITE across 14 traits----------------------------------
# overlapping = no missing data for the 14 traits

cp icd10/unrelated.inds overlap.ind # unrelated white British

dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap.ind temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap.ind
wc -l overlap.ind
echo $tt
done
rm temp

# overlapping + complete data for covariates + unrelated
awk 'NR==FNR{a[$1]; next} ($1 in a) {print $1, $1}' unrelated/overlap.ind white-complete-cov.id > overlap-white-complete-cov.id # N = 147,008

# overlapping UNRELATED ASIAN across 14 traits----------------------------------
cp asian-complete-cov.id overlap-asian-complete-cov.id
dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap-asian-complete-cov.id temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap-asian-complete-cov.id
wc -l overlap-asian-complete-cov.id # N = 4,052
echo $tt
done
rm temp

# relatedness filtering
# see below

# overlapping UNRELATED BLACK across 14 traits----------------------------------
cp black-complete-cov.id overlap-black-complete-cov.id
dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap-black-complete-cov.id temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap-black-complete-cov.id
wc -l overlap-black-complete-cov.id # N = 3,583
echo $tt
done
rm temp

# relatedness filtering
# see below

```

### relatedness filtering

For black and Asian people only.

```{bash eval=F}
#-------------
# 0. make bfiles
#------------

# id lists
overlap-white-complete-cov.id # N=147,008
overlap-black-complete-cov.id # N=3,583
overlap-asian-complete-cov.id # N=4,052
awk '{print $0}' overlap-white-complete-cov.id overlap-black-complete-cov.id overlap-asian-complete-cov.id > overlap-mixed-complete-cov.id # 154,643    

# bfiles by chr
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../overlap-mixed-complete-cov.id \
         --extract ../gen/snps-unrel-inds.use \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-mix \
         --threads 3 \
"> sh_script/chr$j-mix.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i-mix.sh
done>../job-records/mkbfile-mix-pop

# merge bfiles
rm bfile-mix.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-mix" >>bfile-mix.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 10:0:0
./ldak5.1 --make-bed ../gen/geno-mix \
          --mbfile ../gen/bfile-mix.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/merge-mbfiles-mix-pop.sh

# submit the script
sbatch -A snpher ../sh_script/merge-mbfiles-mix-pop.sh >../job-records/merge-mbfiles-mix

#-------
# 1. prune SNPs
#-------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 4
#SBATCH -t 5:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --max-threads 4 \
          --window-prune 0.05 \
          --window-kb 1000 \
          --bfile ../gen/geno-mix \
          --chr $j \
          --thin ../thin/thin-chr$j
"  > sh_script/thin$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/thin$j
done > ../job-records/thin-snps

#-------------
# 2. kinship matrix under GCTA
#-------------

for pop in {black,asian}; do
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 3 \
          --calc-kins-direct ../kinship/$pop-gcta-thin$j \
          --bfile ../gen/geno-mix \
          --keep ../overlap-$pop-complete-cov.id\
          --extract ../thin/thin-chr$j.in \
          --chr $j \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/$pop-grm$j
done
done

# submit files
for pop in {black,asian}; do 
for j in {1..22}; do
sbatch -A snpher ../sh_script/$pop-grm$j
done
done > ../job-records/grm-pops

# merge grms
for pop in {black,asian}; do
rm $pop-grm.list
for j in {1..22} 
do 
echo "../kinship/$pop-gcta-thin$j" >> $pop-grm.list
done
done

for pop in {black,asian}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 80G
#SBATCH -c 10
#SBATCH -t 12:0:0
./ldak5.1 --add-grm ../kinship/$pop-gcta-thin --mgrm ../$pop-grm.list
"> sh_script/$pop-grm.sh
done

for pop in {black,asian}; do
sbatch -A snpher ../sh_script/$pop-grm.sh 
done > ../job-records/grm-merge

#can now delete per-chr files
#rm *gcta-thin{1..22}.*

#-----------------------
# 3. Relatedness filtering 
#------------------------

# relatedness filtering
for pop in {asian,black};do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 2:0:0

./ldak5.1 --filter ../relatedness/$pop-cut.05 \
          --grm ../kinship/$pop-gcta-thin \
          --max-rel 0.05 \
          --max-threads 3
"> sh_script/$pop-rel-cut.05.sh
done

# submit script
for pop in {asian,black};do
sbatch -A snpher ../sh_script/$pop-rel-cut.05.sh
done > ../job-records/relatedness-filtering

# remaining individuals
# asian-cut.05.keep N = 3,448
# black-cut.05.keep N = 3,024
# sum = 6,472
```

### final list

To match the good GWAS, we will have N = 100k in total and replace 6,472 whites with Asians and Blacks.

```{bash eval=F}
# select  
shuf rand.100000 | head -n 93528 > white.rand.93528
cat white.rand.93528 relatedness/asian-cut.05.keep relatedness/black-cut.05.keep > mix-pop-gwas.id 

```

## GWAS-lm

### basic cov

We use basic covariates only: age, sex and townsend.

```{bash eval=F}

# covariates--------------------------------------------------------------------
awk '{print $1, $2, $3, $4, $5}' covariates.use > basic-covariates.use
awk 'NR<=5{print $0}' covariates.use-names > basic-covariates.use

# gwas
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --linear ../gwas-mix/$i-linear-chr-$j \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-mix \
          --covar ../phen/basic-covariates.use \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/snps-unrel-inds.use \
          --max-threads 2 \
          --chr $j
"> sh_script/$i-linear-chr-$j.sh
done
done

# --covar ../phen/covariates.use

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
sbatch -A snpher ../sh_script/$i-linear-chr-$j.sh
done
done>../job-records/gwas-mix-pop

# check job completion----------------------------------------------------------
file=job-records/gwas-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# combine results
# only need .summaries & .pvalues
for i in {awake,bmi,quals,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper}; do 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-chr-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-chr-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-chr-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-chr-$j.pvalues >> $i-linear.pvalues
fi
done
done

```

### basic cov + PC
Here we add PC one at a time until the tenth as covariates and conduct GWAS

```{bash eval=F}
# covariates--------------------------------------------------------------------
R
options(scipen = 999)
require(vroom)
cov=vroom("phen/covariates.phen", col_names=T)
nm=c("eid","age","sex_gen", "townsend", paste0("pc",1:40))
cov=cov[,nm]

for(i in 1:10){
  sel=c("eid","eid","age","sex_gen", "townsend", paste0("pc", 1:i))
  out=cov[,sel]
  file1=paste0("phen/covariates-basic-",i,"PC.use")
  file2=paste0("phen/covariates-basic-",i,"PC.use-names")
  write.table(out,file1, col.names=F, row.names=F,quote=F)
  write.table(names(out),file2, col.names=F, row.names=F,quote=F)
}

# gwas--------------------------------------------------------------------------
for j in {1..10}; do
mkdir gwas-mix-$j'PC'
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
out=../gwas-mix-$j'PC'/$i-linear
cov=../phen/covariates-basic-$j'PC'.use
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 6G
#SBATCH -c 2
#SBATCH -t 6:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-mix \
          --covar $cov \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/snps-unrel-inds.use \
          --max-threads 2 \
"> sh_script/$i-linear-$j'PC'.sh
done
done

# submit files------------------------------------------------------------------
for j in {1..10}; do
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-linear-$j'PC'.sh
done
done>../job-records/gwas-mix-pc

# check job completion----------------------------------------------------------
file=job-records/gwas-mix-pc
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

## GWAS-bolt-lmm

Here we used linear mixed-effects models to test the association between genetic variants and phenotypes. The argument for the use of linear mixed-effects models is that it can account for the confounding effects from population stratification (check the rationale behind BLOT-LMM). Here we check if there is evidence of inflation in the chi-square test statistics from BOLT-LMM.

As shown below, the slopes are sig. different from zero, but they are negative, indicating that chi-square test statistics decreases as aver2_j increases. Based on the plots (chisq ~ aver2_j), it seems that most large signals (i.e., large chisq test statistics) have an aver2_j close to zero, indicating that aver2_j (or fake tagging) does not drive the GWAS signals. However, how aver2_j relates to chisq of bolt-lmm seems different from how aver2_j relates to chisq of good gwas.

```{bash eval=F}

# make filter files-------------------------------------------------------------
fam=gen/geno-mix.fam
bim=gen/geno-mix.bim
id=mix-pop-gwas.id
snp=gen/snps-unrel-inds.use
id_remove=BOLT-LMM_v2.3.5/mix-pop-gwas-id.exclude
snp_exclude=BOLT-LMM_v2.3.5/snps-unrel-inds.remove

awk 'NR==FNR {a[$1];next} 
     !($2 in a) {print $2}' $snp $bim > $snp_exclude
# note the list is empty because $snp & $bim contain the same list
     
awk 'NR==FNR {a[$1];next} 
     !($1 in a) {print $0}' $id $fam > $id_remove

# organize phenotype files------------------------------------------------------
R
options(scipen = 999)
require(vroom)

# covariate file
cov=vroom("phen/covariates.phen", col_names=T)
nm=c("age","sex_gen", "townsend" ,paste0("pc",1:40))

traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(traits)){
    trait=traits[i]
    dat=vroom(paste0("phen/continuous-traits/",trait,".raw.pheno"), col_names=F)
    m=match(dat$X1,cov$eid)
    
    out=data.frame(FID=dat$X1,
                   IID=dat$X2,
                   PHENO=dat$X3,
                   cov[m,nm])
    old=names(out)
    new=c(names(out)[1:3], paste0("COV",1:43))
    names(out)=new
    write.table(out,paste0("BOLT-LMM_v2.3.5/dat/",trait,".dat"), col.names=T,
                row.names=F, quote=F)
    if(i==1){
            out.nm=data.frame(name=new,true_name=old, stringsAsFactors=F)
            write.table(out.nm,"BOLT-LMM_v2.3.5/dat/cov-names", 
            col.names=T, row.names=F, quote=F)
            }
}

# model SNPs--------------------------------------------------------------------
# subset snps used in GRM for BOLT-LMM
# we previously thinned SNPs: see 'relatedness filtering' section of bad GWAS
# Now we just merge them across chromsomes
out=thin/geno-mix-thin-snps
rm $out 
for i in {1..22}; do
awk '{print $0}' thin/thin-chr$i.in >> $out
done

# run BOLT-LMM------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
dir=../gwas-bad
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 10
#SBATCH -t 5:0:0

../bolt --bfile=../gen/geno-mix \
         --phenoFile=../dat/$i.dat \
         --phenoCol=PHENO \
         --remove=../mix-pop-gwas-id.exclude\
         --lmm \
         --LDscoresFile=../tables/LDSCORE.1000G_EUR.tab.gz \
         --LDscoresMatchBp \
         --covarFile=../dat/$i.dat \
         --qCovarCol=COV{1:3}\
         --modelSnps=../geno-mix-thin-snps \
         --maxMissingPerSnp=1 \
         --maxMissingPerIndiv=1 \
         --statsFile=$dir/$i.out \
         --numThreads=10 \
       2>&1 | tee $dir/$i.log
"> sh_script/$i-bolt-lmm.sh
done

# submit scripts
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-bolt-lmm.sh
done>../job-records/bolt-lmm-bad

# check job completion----------------------------------------------------------
file=job-records/bolt-lmm-bad
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# organize results -------------------------------------------------------------
mkdir gwas-norm-337k-out

for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

gwas=gwas-norm-337k/$trait-linear.summaries
aver2=summary/ave-r2-10k-snps-ukbb-norm
out=gwas-norm-337k-out/$trait.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp    

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done

```

## chisq ~ aver2_j

### calc aver2_j

Note we previously computed aver2_j based using `geno-mix` data. see \@ref(aver2j).
Results are stored in `summary/ave-r2-by-snp-badgwas`

### bolt-lmm

```{bash eval=F}

# organize data ----------------------------------------------------------------
mkdir gwas-bolt-lmm-out

for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

gwas=BOLT-LMM_v2.3.5/gwas-bad/$trait.out
aver2=summary/ave-r2-by-snp-badgwas
out=gwas-bolt-lmm-out/$trait.out

awk 'NR>1 {print $1, ($9/$10)^2 }' $gwas > tmp/gwas.tmp    

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done
```

```{r eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::
require(vroom)

traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(traits)){

    trait=traits[i]
    
    file=paste0("gwas-bolt-lmm-out/",trait,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod=lm(chisq ~ aver2,data=dat)
    
    slope0=data.frame(trait=trait,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
}

#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  
#::::::::::::::::::::::::::::::::::::::::::::::

# aver2_j bin-------------------------------

require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

png("fig/chisq-aver2-bin-bad-gwas-bolt-lmm.png", res=600, width=50, height=30, units="cm")
par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(i in 1:length(traits)){
  trait=traits[i]
  dat=vroom(paste0("gwas-bolt-lmm-out/",trait,".out"), col_names=T)
  dat=dat[complete.cases(dat),]

  # linear model
  mod=lm(chisq ~ aver2,data=dat)
  p=summary(mod)$coefficients[,4][2]
  p_sci=formatC(p, format="e", digit=2)

  # bin a variable by quantile
  cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
  
  # average chisq by bin values
  out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
  out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
  px=min(out$bin_val)
  py=max(out$chisq_ave)

  # plot
  plot(out$bin_val, out$chisq_ave,
           xlab="ave r2 bin", ylab="mean chisq",
           main=trait, las=1,
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(mod,col="orange", lwd=2)
  if(p<0.01){text(px, py, paste0("p = ", p_sci),
                  adj=c(0,1), col="red", cex=2)
  } else {text(px, py, paste0("p = ", p_sci), 
          adj=c(0,1), cex=1.2, font=2)}
  
}
dev.off()


# raw aver2_j & chisq-------------------------------

require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
        
png(paste0("fig/chisq-by-aver2-bin-gwas-mix-bold-lmm-raw.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))

for (i in 1:length(traits)){
    trait=traits[i]
    file=paste0("gwas-bolt-lmm-out/",trait,".out")
    dat=vroom(file, col_names=T, delim=";")
    out=dat[complete.cases(dat),]
    
plot(out$aver2, out$chisq,
         xlab="r2", ylab="chisq",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg="gray", col="white", lwd=0.5)
 }
dev.off()

```

### basic cov + PC

```{bash eval=F}

mkdir gwas-mix-pc-out

for j in {1..10}; do
for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

gwas=gwas-mix-$j'PC'/$trait-linear.summaries
aver2=summary/ave-r2-by-snp-badgwas
out=gwas-mix-pc-out/$trait-$j'PC'.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp    

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done
done

```

```{r eval=F}
#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:10){
  
for(i in 1:length(traits)){

    trait=traits[i]
    
    file=paste0("gwas-mix-pc-out/",trait,"-",j,"PC.out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod=lm(chisq ~ aver2,data=dat)
    
    slope0=data.frame(trait=trait,
                      pc_up_to=j,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1 & j==1){slope=slope0} else {slope=rbind(slope,slope0)}
    }
}

#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  
#::::::::::::::::::::::::::::::::::::::::::::::

# binned data -------------------------------------

require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:10){
  
  png(paste0("fig/chisq-by-aver2-bin-bad-gwas-",j,"PC.png"), 
      res=600, width=50, height=30, units="cm")
  
  par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

    for(i in 1:length(traits)){
      trait=traits[i]
      file=paste0("gwas-mix-pc-out/",trait,"-",j,"PC.out")
      dat=vroom(file, col_names=T)
      dat=dat[complete.cases(dat),]
    
      # linear model
      mod=lm(chisq ~ aver2,data=dat)
      p=summary(mod)$coefficients[,4][2]
      p_sci=formatC(p, format="e", digit=2)
    
      # bin a variable by quantile
      cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
      dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
      
      # average chisq by bin values
      out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
      out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
      px=min(out$bin_val)
      py=max(out$chisq_ave)
    
      # plot
      plot(out$bin_val, out$chisq_ave,
               xlab="ave r2 bin", ylab="mean chisq",
               main=paste0(trait, " ", j, " PC"), las=1,
               cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
      abline(mod,col="orange", lwd=2)
      if(p<0.01){text(px, py, paste0("p = ", p_sci),
                      adj=c(0,1), col="red", cex=2, font=2)
      } else {text(px, py, paste0("p = ", p_sci), 
              adj=c(0,1), cex=2, font=2)}
    }
    dev.off()

}

# binned data. single trait varying # of PC ------------------------------------
# BMI
require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

png(paste0("fig/chisq-by-aver2-bin-bad-gwas-varying-PC-bmi.png"), 
      res=600, width=40, height=30, units="cm")
par(mfrow=c(3,4), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(j in 1:10){
    
      trait=traits[2]
      file=paste0("gwas-mix-pc-out/",trait,"-",j,"PC.out")
      dat=vroom(file, col_names=T)
      dat=dat[complete.cases(dat),]
    
      # linear model
      mod=lm(chisq ~ aver2,data=dat)
      p=summary(mod)$coefficients[,4][2]
      p_sci=formatC(p, format="e", digit=2)
    
      # bin a variable by quantile
      cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
      dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
      
      # average chisq by bin values
      out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
      out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
      px=min(out$bin_val)
      py=max(out$chisq_ave)
    
      # plot
      plot(out$bin_val, out$chisq_ave,
               xlab="ave r2 bin", ylab="mean chisq",
               main=paste0(trait, " ", j, " PC"), las=1,
               cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
      abline(mod,col="orange", lwd=2)
      if(p<0.01){text(px, py, paste0("p = ", p_sci),
                      adj=c(0,1), col="red", cex=2, font=2)
      } else {text(px, py, paste0("p = ", p_sci), 
              adj=c(0,1), cex=2, font=2)}
    }
dev.off()

# reaction
require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

png(paste0("fig/chisq-by-aver2-bin-bad-gwas-varying-PC-reaction.png"), 
      res=600, width=40, height=30, units="cm")
par(mfrow=c(3,4), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(j in 1:10){
    
      trait=traits[11]
      file=paste0("gwas-mix-pc-out/",trait,"-",j,"PC.out")
      dat=vroom(file, col_names=T)
      dat=dat[complete.cases(dat),]
    
      # linear model
      mod=lm(chisq ~ aver2,data=dat)
      p=summary(mod)$coefficients[,4][2]
      p_sci=formatC(p, format="e", digit=2)
    
      # bin a variable by quantile
      cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
      dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
      
      # average chisq by bin values
      out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
      out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
      px=min(out$bin_val)
      py=max(out$chisq_ave)
    
      # plot
      plot(out$bin_val, out$chisq_ave,
               xlab="ave r2 bin", ylab="mean chisq",
               main=paste0(trait, " ", j, " PC"), las=1,
               cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
      abline(mod,col="orange", lwd=2)
      if(p<0.01){text(px, py, paste0("p = ", p_sci),
                      adj=c(0,1), col="red", cex=2, font=2)
      } else {text(px, py, paste0("p = ", p_sci), 
              adj=c(0,1), cex=2, font=2)}
    }
dev.off()

# raw data-------------------------------------------------------------------

require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:10){
  
png(paste0("fig/chisq-by-aver2-gwas-mix-",j,"PC-raw.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))

for (i in 1:length(traits)){
    trait=traits[i]
    file=paste0("gwas-mix-pc-out/",trait,"-",j,"PC.out")
    dat=vroom(file, col_names=T, delim=";")
    out=dat[complete.cases(dat),]

plot(out$aver2, out$chisq,
         xlab="ave r2", ylab="ave chisq",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg="orange", col="white", lwd=0.5)
 }
dev.off()
}

```

## ldsc intercept

### under gcta
```{bash eval=F}
#:::::::::::::
# using original ldsc
#:::::::::::::

# format stats for ldsc--------------------------------------------------------- 
library(vroom)
options(scipen = 100)
rs=vroom("doug/ukbb.ldsc", col_names=F)
phen=c("awake","bmi","chron","ever","fvc",
       "height","imp","neur","pulse","quals",
       "reaction","sbp","snoring","hyper", "quals")

for(i in phen){
  stat=vroom(paste0("gwas-mix/",i,"-linear.summaries"), col_names=T)
  p=vroom(paste0("gwas-mix/",i,"-linear.pvalues"), col_names=T)
  m1=match(rs$X1, stat$Predictor)
  m2=match(rs$X1, p$Predictor)
  out=data.frame(SNP=rs$X2,
                 N=stat$n[m1],
                 Z=(sqrt(stat$Stat)*stat$Direction)[m1],
                 A1=stat$A1[m1],
                 A2=stat$A2[m1], 
                 pval=p$P[m2], stringsAsFactors=F)
  out=out[complete.cases(out),]
  write.table(out, paste0("gwas-mix/",i,"-linear-rs.summaries"), 
  col.names=T, row.names=F, quote=F)
}

# perform ldsc------------------------------------------------------------------
mkdir out-mix-pop
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 3
#SBATCH -t 08:00:0

.././munge_sumstats.py \
--sumstats ../../gwas-mix/$i-linear-rs.summaries \
--out ../out-mix-pop/$i \
--merge-alleles ../w_hm3.snplist

.././ldsc.py \
--h2 ../out-mix-pop/$i.sumstats.gz \
--ref-ld-chr ../eur_w_ld_chr/ \
--w-ld-chr ../eur_w_ld_chr/ \
--out ../out-mix-pop/$i-ldsc
">sh_script/ldsc-$i-mix-pop.sh
done

# submit jobs-------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper,quals}; do
sbatch -A snpher ../sh_script/ldsc-$i-mix-pop.sh
done>../../job-records/ldsc-mix-pop

# check job completion----------------------------------------------------------
file=job-records/ldsc-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::::::::::
# using sumher
#:::::::::::::

# insert genetic distance into bim file-----------------------------------------
# here we want to use the same genetic distance as for unrelated individuals, i.e., good GWAS
R
dat=read.table("gen/geno-mix.bim", header=F, stringsAsFactors=F)
ref=read.table("gen/geno-unrel.bim", header=F, stringsAsFactors=F)
m=match(dat$V2,ref$V2)
out=data.frame(dat$V1, dat$V2, ref$V3[m], dat$V4, dat$V5, dat$V6, stringsAsFactors=F)
write.table(out,"gen/geno-mix.bim2", col.names=F, row.names=F, quote=F)

mv geno-mix.bim geno-mix.bim0
mv geno-mix.bim2 geno-mix.bim

# compute tagging under gcta----------------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --calc-tagging ../tagging-mix-pop/gcta-hapmap3-chr-$j \
          --bfile ../gen/geno-mix \
          --ignore-weights YES \
          --power -1 \
          --window-cm 1 \
          --chr $j
"> sh_script/tagging-gcta-hapmap3-chr$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-gcta-hapmap3-chr$j 
done > ../job-records/tagging-gcta-hadmap3-mix-pop

# check job completion----------------------------------------------------------
file=job-records/tagging-gcta-hadmap3-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
for j in {1..22}; do 
echo "tagging-mix-pop/gcta-hapmap3-chr-$j.tagging" >> list.txt
done
./ldak5.1 --join-tagging tagging-mix-pop/gcta-hapmap3 --taglist list.txt

# ldsc intercept----------------------------------------------------------------
mkdir sumher-mix
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --sum-hers ../sumher-mix/$i-sumher-gcta \
          --tagfile ../tagging-mix-pop/gcta-hapmap3.tagging \
          --summary ../gwas-mix/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-gcta-mix-pop
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-gcta-mix-pop
done>../job-records/sumher-gcta-mix-pop

# check job completion----------------------------------------------------------
file=job-records/sumher-gcta-mix-pop
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### under ldak-thin

```{bash eval=F}
# get weights-------------------------------------------------------------------
awk < ldak-thin/ldak-thin-hapmap3.in '{print $1, 1}' > ldak-thin/weights.ldak-thin-hapmap3

# calculate tagging under ldak-thin---------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 40G
#SBATCH -c 5
#SBATCH -t 10:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --calc-tagging ../tagging-mix-pop/ldak-thin-hapmap3-chr-$j \
          --bfile ../gen/geno-mix \
          --weights ../ldak-thin/weights.ldak-thin-hapmap3 \
          --power -.25 \
          --window-cm 1 \
          --chr $j \
          --save-matrix YES \
          --max-threads 5
" > sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done

# submit scripts
for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done > ../job-records/tagging-ldak-thin-hapmap3

# check job completion----------------------------------------------------------
file=job-records/tagging-ldak-thin-hapmap3
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
rm matlist.txt
for j in {1..22}; do 
echo "tagging-mix-pop/ldak-thin-hapmap3-chr-$j.tagging" >> list.txt
echo "tagging-mix-pop/ldak-thin-hapmap3-chr-$j.matrix" >> matlist.txt
done
./ldak5.1 --join-tagging tagging-mix-pop/ldak-thin-hapmap3 --taglist list.txt --matlist matlist.txt

# ldsc intercept----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --sum-hers ../sumher-mix/$i-sumher-ldak-thin \
          --tagfile ../tagging-mix-pop/ldak-thin-hapmap3.tagging \
          --summary ../gwas-mix/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-ldak-thin-mix
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-ldak-thin-mix
done>../job-records/sumher-ldak-thin-mix

# check job-completion
file=job-records/sumher-ldak-thin-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### summary

```{bash eval=F}

# without 40 PCs----------------------------------------------------------------------
# original ldsc
grep Intercept *ldsc.log | awk '{split($1, a, /[-]/); split($3, b, /[()]/); print a[1], $2, b[2]}' > ../../summary/ldsc-mix

# sumher under gcta
grep Intercept_Estimate *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-est
grep Intercept_SD *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-sd
cd ../summary/
paste sumher-gcta-mix-est sumher-gcta-mix-sd | awk '{print $1, $2, $4}' > sumher-gcta-mix
rm sumher-gcta-mix-sd sumher-gcta-mix-est
      
# suhmer under ldak-thin
grep Intercept_Estimate *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-est
grep Intercept_SD *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-sd
cd ../summary/
paste sumher-ldak-thin-mix-est sumher-ldak-thin-mix-sd | awk '{print $1, $2, $4}' > sumher-ldak-thin-mix
rm sumher-ldak-thin-mix-sd sumher-ldak-thin-mix-est

# with covariates (i.e., including all 40 PCs)-------------------------------------------

# original ldsc
grep Intercept *ldsc.log | awk '{split($1, a, /[-]/); split($3, b, /[()]/); print a[1], $2, b[2]}' > ../../summary/ldsc-mix-with-cov

# sumher under gcta
grep Intercept_Estimate *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-est
grep Intercept_SD *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-mix-sd
cd ../summary/
paste sumher-gcta-mix-est sumher-gcta-mix-sd | awk '{print $1, $2, $4}' > sumher-gcta-mix-with-cov
rm sumher-gcta-mix-sd sumher-gcta-mix-est
      
# suhmer under ldak-thin
grep Intercept_Estimate *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-est
grep Intercept_SD *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-mix-sd
cd ../summary/
paste sumher-ldak-thin-mix-est sumher-ldak-thin-mix-sd | awk '{print $1, $2, $4}' > sumher-ldak-thin-mix-with-cov
rm sumher-ldak-thin-mix-sd sumher-ldak-thin-mix-est

```

## REML
### making grms
```{bash eval=F}
# making grm -------------------------------------------------------------------

#:::
# under gcta
#:::

# all snps
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 120G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-all-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-all-snps-mix

sbatch -A snpher ../sh_script/grm-all-snps-mix > ../job-records/grm-all-snps-mix

# grm by snp blocks: right vs. left
awk '$1<8 {print $2}' geno-mix.bim > left-mix-pop.snps 
awk '$1>=8 {print $2}' geno-mix.bim > right-mix-pop.snps

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-$i-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/$i-mix-pop.snps \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-gcta-$i-mix
done

for i in left right; do
sbatch -A snpher ../sh_script/grm-gcta-$i-mix 
done > ../job-records/grm-gcta-by-snps-mix

# check job completion----------------------------------------------------------
file=job-records/grm-gcta-by-snps-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::
# under ldak-thin
#:::

#-----------
# 1. thin snps
#-----------
# we omit this step and use ldak-thin/ldak-thin-hapmap3.in, which was created previously
# using geno-unrel bfiles. See above.

#----------------------
# 2. kinship matrix under ldak-thin
#------------------------

echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-all-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../ldak-thin/ldak-thin-hapmap3.in \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-all-snps-mix

sbatch -A snpher ../sh_script/ldak-thin-grm-all-snps-mix> ../job-records/ldak-thin-grm-all-snps-mix

# grm by snp blocks: right vs. left

awk '{split($1, a, /[:]/); if (a[1]<8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/left-ldak-thin-hapmap3.snps 
awk '{split($1, a, /[:]/); if (a[1]>=8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/right-ldak-thin-hapmap3.snps 

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-$i-mix \
          --bfile ../gen/geno-mix \
          --keep ../mix-pop-gwas.id \
          --extract ../gen/$i-ldak-thin-hapmap3.snps \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-$i-mix
done

for i in left right; do
sbatch -A snpher ../sh_script/ldak-thin-grm-$i-mix 
done > ../job-records/grm-ldak-thin-by-snps-mix

# check job completion----------------------------------------------------------
file=job-records/grm-ldak-thin-by-snps-mix
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### fast-reml
```{bash eval=F}

#:::
# under gcta
#:::

# make script files-------------------------------------------------------------
mkdir reml-mix
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-mix/$i-gcta-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --covar ../phen/basic-covariates.use \
          --grm ../kinship/gcta-$k-mix \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-mix-gcta-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-mix-gcta-$k-snps
done
done>../job-records/reml-mix-gcta

# check job completion----------------------------------------------------------
file=job-records/reml-mix-gcta
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# cancel jobs 
for i in {1..14}; do
job=`awk -v i=$i 'NR==i{print $0}' kill-jobs`
scancel $job
done

#:::
# under ldak-thin
#:::

# make script files-------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-mix/$i-ldak-thin-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --covar ../phen/basic-covariates.use \
          --grm ../kinship/ldak-thin-$k-mix \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-mix-ldak-thin-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-mix-ldak-thin-$k-snps
done
done >../job-records/reml-mix-ldak-thin

# check job completion----------------------------------------------------------
file=job-records/reml-mix-ldak-thin
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### inflation test

```{bash eval=F}
#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-gcta-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-mix.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/reml-gcta-mix.all"), header=T)
left=read.table(paste0("summary/reml-gcta-mix.left"), header=T)
right=read.table(paste0("summary/reml-gcta-mix.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/reml-gcta-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-mix/$i-ldak-thin-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-mix.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R
full=read.table(paste0("summary/reml-ldak-thin-mix.all"), header=T)
left=read.table(paste0("summary/reml-ldak-thin-mix.left"), header=T)
right=read.table(paste0("summary/reml-ldak-thin-mix.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}

write.table(out, paste0("summary/reml-ldak-thin-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

```


## HE

### estimation 

```{bash eval=F}
# regress grm on covariates-----------------------------------------------------

for grm in gcta-all-mix gcta-left-mix gcta-right-mix ldak-thin-all-mix ldak-thin-left-mix ldak-thin-right-mix; do  
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 50G
#SBATCH -c 5
#SBATCH -t 10:0:0
./ldak5.1 --adjust-grm ../kinship/$grm.covar \
          --grm ../kinship/$grm \
          --covar ../phen/basic-covariates.use \
          --max-threads 5
"> sh_script/$grm-adjust.sh
done

# submit jobs
for grm in gcta-all-mix gcta-left-mix gcta-right-mix ldak-thin-all-mix ldak-thin-left-mix ldak-thin-right-mix; do
sbatch -A snpher ../sh_script/$grm-adjust.sh
done > ../job-records/grm-adjust-for-HE

# check job completion----------------------------------------------------------
file=job-records/grm-adjust-for-HE
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# HE under gcta-----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --he ../he-mix/$i-he-gcta-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/gcta-$k-mix.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/basic-covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-gcta-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-gcta-$k-snps.sh
done
done > ../job-records/he-gcta

# HE under ldak-thin------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 0:30:0

./ldak5.1 --he ../he-mix/$i-he-ldak-thin-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/ldak-thin-$k-mix.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/basic-covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-ldak-thin-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-ldak-thin-$k-snps.sh
done
done > ../job-records/he-ldak-thin

```

### summary

```{bash eval=F}

#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-gcta-mix.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.right
done

# left
rm summary/he-gcta-mix.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.left
done

# all
rm summary/he-gcta-mix.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-mix.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-gcta-mix.all"), header=F)
left=read.table(paste0("summary/he-gcta-mix.left"), header=F)
right=read.table(paste0("summary/he-gcta-mix.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-gcta-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)


#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-ldak-thin-mix.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-ldak-thin-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.right
done

# left
rm summary/he-ldak-thin-mix.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-ldak-thin-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.left
done

# all
rm summary/he-ldak-thin-mix.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-mix/$i-he-gcta-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-mix.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-ldak-thin-mix.all"), header=F)
left=read.table(paste0("summary/he-ldak-thin-mix.left"), header=F)
right=read.table(paste0("summary/he-ldak-thin-mix.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-ldak-thin-inflation-mix-gwas.txt"),
            col.names=T, row.names=F, quote=F)

```


