
# inflation ~ ave $r^2_j$

New measure of inflation, $r^2_j$ - average correlation between SNP j and distant SNPs.

1. Check if the maths in ldak function is correct. Use --make-snps to generate clean data, and check estimates of average r2j are not significant.

Average squared correlation is 1.000060e-05; chi-squared test statistic 0.126985; p-value 7.215786e-01.

```{bash eval=F}

#:::
# 0. simulate genotypes
#:::

./ldak5.1 --make-snps inflation/random-snps/20k-snps-100k-inds --num-samples 100000 --num-snps 20000

# create snp lists
dir=inflation/random-snps
awk 'NR <= 10000 {print $2}' $dir/20k-snps-100k-inds.bim > $dir/lista
awk 'NR > 10000 {print $2}' $dir/20k-snps-100k-inds.bim > $dir/listb

#:::
# 1. compute r2_j for each SNP_j
#:::

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 2:00:0

dir=../inflation/random-snps

./ldak5.2 --max-threads 10 \
          --calc-inflation \$dir/out/20k-random-snps-100k-inds \
          --bfile \$dir/20k-snps-100k-inds \
          --lista \$dir/lista \
          --listb \$dir/listb 

">sh_script/calc-sum-r2

# submit the job
sbatch -A snpher ../sh_script/calc-sum-r2 >../job-records/calc-sum-r2-random-snps

```


2. Ideally, we show r2j is robust - e.g., it is not sensitive to choice of SNPs (e.g., randomly pick 1000, then a different 1000). It is not sensitive to MAF threshold (e.g., if you restrict to MAF>.1, MAF>.01, MAF>.001).

  * sensitive to the choice of SNPs? var(r^2_j) for a given j. 
  * sensitive to the number of SNPs? 1k, 5k, 10k, 20k
  * sensitive to MAF threshold? MAF > .1, MAF > 0.01, MAF > 0.001

Central limit theorem > Normal distribution
Maybe we could use the mean instead.

## m=1k & maf=0.01
```{bash eval=F}

#:::
# 1. compute r^2
#:::

# lista: 1k from chrom1-7. This is list is fixed for all conditions
dir=inflation/sensitivity
maf=.01
awk '{split($1, a, ":"); if (a[1]<8) print $1 }' gen/snps-unrel-inds.use | shuf | head -n 1000 >$dir/lista-maf$maf

#::::::::
# m=1k & maf = .01
#::::::::

# to change
nm=1k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=1000
nm=1k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=1k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

```

```{r eval=F}

#:::
# define a R function to compute ave r_j^2 for each i
#:::

options(stringsAsFactors=FALSE)
ip<-commandArgs(trailingOnly=TRUE)
options(warn=1)

compute_ave_r2=function(m,nm,maf){

m=as.numeric(m)
nm=as.character(nm)
maf=as.character(maf)
dir=paste0("../inflation/sensitivity/maf",maf)

require(vroom)
names=c("good", "bad")

for(i in 1:length(names)){
gwas=names[i]
dat=vroom(paste0(dir,"/out/", nm,"-maf",maf,"-snps-", gwas,".pairwise"), col_names=F)
dat=dat[,-c(m+1)]^2
out=t(data.frame(ave_r2=apply(dat,1, mean)))
write.table(out,paste0(dir,"/ave-r2-",nm,"-",gwas), col.names=F, row.names=F, quote=F, append=T)
 }
}

compute_ave_r2(ip[1],ip[2],ip[3])

```

## m=5k & maf=0.01
```{bash eval=F}

#::::::::
# m=5k & maf = .01
#::::::::

# to change
nm=5k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=5000
nm=5k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=5k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

```

## m=10k & maf=0.01
```{bash eval=F}

#::::::::
# m=10k & maf = .01
#::::::::

# to change
nm=10k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=10000
nm=10k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=10k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

```

## m=20k & maf=0.01

```{bash eval=F}

#::::::::
# m=20k & maf = .01
#::::::::

# to change
nm=20k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=20000
nm=20k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=20k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

```


## summary

```{r eval=F}

require(vroom)
dir="inflation/sensitivity/maf.01/"
snps=read.table(paste0(dir,"/out/1k-maf.01-snps-bad.predictorsa"), stringsAsFactors = F, header=F)
# note: the snp set for list a is constant across different m's

# extract data
m=c("1k","5k","10k", "20k")

for(i in 1:length(m)){
  
  dat=vroom(paste0(dir,"ave-r2-",m[i],"-bad"),col_names=F)
  ave0=apply(dat,2,mean)
  sd0=apply(dat,2,sd)

  if(i==1){ave=data.frame(snp=snps$V1,ave0, stringsAsFactors = F);
            names(ave)[i+1]=paste0("m_",m[i])
            sd=data.frame(snp=snps$V1,sd0, stringsAsFactors = F);
            names(sd)[i+1]=paste0("m_",m[i])
  } else {ave=cbind(ave,ave0); 
          names(ave)[i+1]=paste0("m_",m[i])
          sd=cbind(sd,sd0); 
          names(sd)[i+1]=paste0("m_",m[i])
          } 
}

# organize data
ord=order(ave$m_20k,decreasing=F)
ave=ave[ord,]
sd=sd[ord,]

cutoff=quantile(ave$m_20k, probs = seq(0, 1, 0.01))
ave$quant_bin=cut(ave$m_20k, breaks=cutoff, 
                  include.lowest=T,
                  labels=1:(length(cutoff)-1))

# check alignment of ave r^2_j for different m
require(vroom)
dir="inflation/sensitivity/maf.01/"
snps=read.table(paste0(dir,"/out/1k-maf.01-snps-bad.predictorsa"), stringsAsFactors = F, header=F)
# note: the snp set for list a is constant across different m's

# extract data
png("fig/ave-r2-1st-vs-2nd-run-by-m.png", res=400 , width=40, height=10, units="cm")
par(mfrow=c(1,4), pty="s")
m=c("1k","5k","10k", "20k")
for(i in 1:length(m)){
  dat=vroom(paste0(dir,"ave-r2-",m[i],"-bad"),col_names=F)
  sel=t(dat[c(5,20),])
  start=min(c(sel[,1],sel[,2]))
  end=max(c(sel[,1],sel[,2]))
  plot(sel[,1], sel[,2],
       xlim=c(start,end), ylim=c(start, end),
      xlab="1st run", ylab="2nd run", main=m[i], las=1,
     cex = 1, pch=21,  bg="darkgray", col="white", lwd=0.5)
abline(0, 1, col="darkgray", lwd=1.5, lty=1)
}
dev.off()

```


```{r eval=F}

## PLOTS TO WORK ON
png("fig/ave-r2.png", res=400 , width=30, height=20, units="cm")
#par(mfrow=c(1,3))
#par(mar=c(5, 14, 2, 2))
# set up plotting region

##### UP TO HERE

png("fig/ave-r2.png", res=400 , width=20, height=20, units="cm")
plot(ave$m_1k[1:10], 1:10, type="n", xaxt="n", yaxt="n", 
     xlim=c(-0.1, 0.6), ylim=c(0, dim(dat2)[1]+0.5), 
     #xaxs="i", yaxs="i", 
     xlab="", ylab="", bty="n")
# add upper and lower bounds
for (i in 1:10) lines(x=c(ave$m_1k[i], ave$m_1k[i]+2*sd$m_1k[i]), 
                      y=c(i,i),lwd=3,lty=1,col="lightgrey")
for (i in 1:10) lines(x=c(ave$m_1k[i]-2*sd$m_1k[i], ave$m_1k[i]),
                      y=c(i,i),lwd=3, lty=1, col="lightgrey")
# add point estimates
points(x=ave$m_1k[1:10],y=1:10, pch=19, cex=1.2, col="powderblue")
# label points

# add x- axis 
#axis(1, at=0.1*(0:6), labels=TRUE, tick=TRUE, outer=FALSE)
#axis(2, at=1:dim(dat2)[1]+0.1, labels=dat2$full, tick=FALSE, outer=FALSE, las=2,
#     hadj=1, padj=1, xpd=T)

# add lables along y axis
#mtext("Trait",at=c(-0.08,11),adj=1,cex=2,col="steelblue", font=2)
#mtext("N",at=c(-0.015,11),adj=1,cex=2,col="steelblue", font=2)


# add trait names, n & p-values
#for (i in seq(1,10,by=1)) text(-0.07,i,dat2$full[i],cex=1.5, adj=1, font=2, xpd=T)
#for (i in seq(1,10,by=1)) text(-0.01,i,dat2$n[i],cex=1.1, adj=1, font=2, xpd=T, col="slategray")
#text(0.3, -1 , "SNP-based Heritability Estimate (95% CI)",adj=0.5,cex=1.2, font=1, xpd=T)

dev.off()

```

3. Show that estimated inflation correlates well with difference in $\overline{r_j^2}$ between bad and good GWAS.
I guess it will be nice to have more variety. E.g., instead of good and bad, have good, a bit bad (e.g., 1000 non-europeans), a bit more bad (2000 non-europeans), ... bad (7000 non-europeans).

Would be great to know the slope of this regression. Can you estimate it by regressing $S_j$ on $\overline{r_j^2}$ from the bad GWAS? But if we can, we just say the slope is less than n

You showed that if you regress inflation on $\overline{r_j^2}$ and MAF, that MAF is not significant (nor if you use log(MAF) or exp(MAF) or (MAFX(1-MAF))).
Can you also include info score - hopefully this is also not significant.
If Maf and Info scores are redundant, this strengthens argument for using r2j


```{bash eval=F}


```

We can now report average inflation of test statistics (mean(r2j) x n x h2, which is upper bounded by mean(r2j) x n), AND we can report estimated per-SNP inflation of test statistics (r2j x n x j2)

Eg., we can say that if you use UKBB recommended samples, with MAF>.01, the average inflation will be less than 0.5 units, while the maximum inflation will be less than 1 unit.

However, maybe we find that if you analyse rare SNPs (e.g. 0.0001 < MAF < .01), the maximum inflation is much higher (so people must be careful).

What happens if you have a meta-analysis - how does inflation accumulate over cohorts?


Possible way to write up this paper:

Perform a good and bad GWAS of height

Figure 1a - show that GIF performs poorly (because test statistics of good GWAS do not follow a chisq(1) distribution)

Figure 1b - use test statistics of good GWAS to show that LDSC performs badly, because it assumes causal variation is constant [Do you mean the choice of heritability model affects inflation estimates? But we found for good GWASs, ldsc under gcta is OK for most traits.]

Figure 1c - use difference between test statistics to show that LDSC performs badly because it assumes inflation is constant.

(in supplement, can show same results for other traits).

Figure 2 - show that r2j is independent of true signal (test statistics from good gwas), but predicts well inflation (difference)
