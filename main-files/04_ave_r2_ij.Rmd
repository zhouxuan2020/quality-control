
# chi square ~ $\overline{r^2_j}$

New measure of inflation, $\overline{r^2_j}$ - average correlation between SNP j and distant SNPs.

1. Check if the maths in ldak function is correct. Use --make-snps to generate clean data, and check estimates of average r2j are not significant.

We did 10 runs and results are non-significant.

```{bash eval=F}

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 5:00:0

for i in {1..10}; do
  
  dir=../inflation/random-snps
  
  # simulate random snps -------------------------------------------------------
  ./ldak5.1 --make-snps \$dir/20k-snps-100k-inds --num-samples 100000 --num-snps 20000
  
  # create snp lists -----------------------------------------------------------
  awk 'NR <= 10000 {print \$2}' \$dir/20k-snps-100k-inds.bim > \$dir/lista
  awk 'NR > 10000 {print \$2}' \$dir/20k-snps-100k-inds.bim > \$dir/listb
  
  # compute r_ij --------------------------------------------------------------
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/20k-random-snps-100k-inds \
            --bfile \$dir/20k-snps-100k-inds \
            --lista \$dir/lista \
            --listb \$dir/listb
done
">sh_script/calc-ave-r2j

# submit the job
sbatch -A snpher ../sh_script/calc-ave-r2j >../job-records/calc-ave-r2j-random-snps

# results
grep "Average squared correlation" sh_out/calc-ave-r2j-60721312.out > inflation/random-snps/out/ave-r2j.out

```

## $\overline{r^2_j}$ & choice of SNPs 

### number of SNPs

2. Ideally, we show $\overline{r^2_j}$ is robust - e.g., it is not sensitive to choice of SNPs (e.g., randomly pick 1000, then a different 1000). It is not sensitive to MAF threshold (e.g., if you restrict to MAF>.1, MAF>.01, MAF>.001).

To test the robustness of $\overline{r^2_j}$, we randomly chose 1k SNPs from chromosomes 1-7 and computed the $\overline{r^2_j}$ for these SNPs using 1k, 5k, 10k and 20k SNPs chosen randomly from chromosomes 8-22. We resampled the SNPs and repeated the calculation for 100 times.

So we want to test if $\overline{r^2_j}$ is sensitive to 
  * the choice of SNPs? var(r^2_j) for a given j. 
  * the number of SNPs? 1k, 5k, 10k, 20k
  * the MAF threshold? MAF > .1, MAF > 0.01, MAF > 0.001
  
  * For MAF > 0.01, $\overline{r^2_j}$ is not sensitive to the choice of SNPs and slightly sensitive to the number of SNPs. Based on different set of SNPs, $\overline{r^2_j}$ align well. The alignment is better for m > 10k than for m < 10k. 

```{bash eval=F}

#:::
# define a R function to compute ave r_j^2 for each i
# To be used below
#:::

options(stringsAsFactors=FALSE)
ip<-commandArgs(trailingOnly=TRUE)
options(warn=1)

compute_ave_r2=function(m,nm,maf){

m=as.numeric(m)
nm=as.character(nm)
maf=as.character(maf)
dir=paste0("../inflation/sensitivity/maf",maf)

require(vroom)
names=c("good", "bad")

for(i in 1:length(names)){
gwas=names[i]
dat=vroom(paste0(dir,"/out/", nm,"-maf",maf,"-snps-", gwas,".pairwise"), col_names=F)
dat=dat[,-c(m+1)]^2
out=t(data.frame(ave_r2=apply(dat,1, mean)))
write.table(out,paste0(dir,"/ave-r2-",nm,"-",gwas), col.names=F, row.names=F, quote=F, append=T)
 }
}

compute_ave_r2(ip[1],ip[2],ip[3])

#:::
# 0. compute r^2
#:::

# lista: 1k from chrom1-7. This is list is fixed for all conditions
dir=inflation/sensitivity
maf=.01
awk '{split($1, a, ":"); if (a[1]<8) print $1 }' gen/snps-unrel-inds.use | shuf | head -n 1000 >$dir/lista-maf$maf

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# m=1k & maf = .01 
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# to change
nm=1k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=1000
nm=1k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=1k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# m=5k & maf = .01
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# to change
nm=5k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=5000
nm=5k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=5k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# m=10k & maf = .01
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# to change
nm=10k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=10000
nm=10k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=10k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# m=20k & maf = .01
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# to change
nm=20k
maf=.01

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 20:00:0

#:::
# 0. define vars & create snp lists
#:::

for i in {1..100}; do

# to change
use=../gen/snps-unrel-inds.use
m=20000
nm=20k
maf=.01
lista=../inflation/sensitivity/lista-maf\$maf
dir=../inflation/sensitivity/maf\$maf
listb=\$dir/listb-\$nm-maf\$maf


  #::
  # 1. select list b [to be recycled]
  #::
  
  awk '{split(\$1, a, \":\"); if (a[1]>=8) print \$1 }' \$use | shuf | head -n \$m >\$listb
  
  #::
  # 2. good gwas
  #::
  
  id=../unrelated/rand.100000
  bfile=../gen/geno-unrel
  out=\$nm-maf\$maf-snps-good
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 
  
  #::
  # 3. bad gwas
  #::
  
  id=../mix-pop-gwas.id
  bfile=../gen/geno-mix
  out=\$nm-maf\$maf-snps-bad
    
  ./ldak5.2 --max-threads 10 \
            --calc-inflation \$dir/out/\$out \
            --bfile \$bfile \
            --keep \$id \
            --lista \$lista \
            --listb \$listb 

  #::
  # 4. compute ave r2 [each column corresponds to a SNP in lista]
  #::
  
  Rscript --vanilla ../inflation/sensitivity/calc-ave-r2.r \$m \$nm \$maf
  
done

">sh_script/calc-ave-r2-$nm-maf$maf

# submit the job
nm=20k
maf=.01
sbatch -A snpher ../sh_script/calc-ave-r2-$nm-maf$maf >../job-records/calc-ave-r2-$nm-maf$maf

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#    summary
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)
dir="inflation/sensitivity/maf.01/"
snps=read.table(paste0(dir,"/out/1k-maf.01-snps-bad.predictorsa"), 
                stringsAsFactors = F, header=F)
# note: the snp set for list a is constant across different m's

# extract data
m=c("1k","5k","10k", "20k")

for(i in 1:length(m)){
  
  dat=vroom(paste0(dir,"ave-r2-",m[i],"-bad"),col_names=F)
  ave0=apply(dat,2,mean)
  sd0=apply(dat,2,sd)

  if(i==1){ave=data.frame(snp=snps$V1,ave0, stringsAsFactors = F);
            names(ave)[i+1]=paste0("m_",m[i])
            sd=data.frame(snp=snps$V1,sd0, stringsAsFactors = F);
            names(sd)[i+1]=paste0("m_",m[i])
  } else {ave=cbind(ave,ave0); 
          names(ave)[i+1]=paste0("m_",m[i])
          sd=cbind(sd,sd0); 
          names(sd)[i+1]=paste0("m_",m[i])
          } 
}

# organize data
ord=order(ave$m_20k,decreasing=F)
ave=ave[ord,]
sd=sd[ord,]

cutoff=quantile(ave$m_20k, probs = seq(0, 1, 0.01))
ave$quant_bin=cut(ave$m_20k, breaks=cutoff, 
                  include.lowest=T,
                  labels=1:(length(cutoff)-1))

# check alignment of ave r^2_j for different m
require(vroom)
dir="inflation/sensitivity/maf.01/"
snps=read.table(paste0(dir,"/out/1k-maf.01-snps-bad.predictorsa"),
                stringsAsFactors = F, header=F)
# note: the snp set for list a is constant across different m's

# extract data
png("fig/ave-r2-1st-vs-2nd-run-by-m.png", res=400 , width=40, height=10, units="cm")
par(mfrow=c(1,4), pty="s")
m=c("1k","5k","10k", "20k")
for(i in 1:length(m)){
  dat=vroom(paste0(dir,"ave-r2-",m[i],"-bad"),col_names=F)
  sel=t(dat[c(5,20),])
  start=min(c(sel[,1],sel[,2]))
  end=max(c(sel[,1],sel[,2]))
  plot(sel[,1], sel[,2],
       xlim=c(start,end), ylim=c(start, end),
      xlab="1st run", ylab="2nd run", main=m[i], las=1,
     cex = 1, pch=21,  bg="darkgray", col="white", lwd=0.5)
abline(0, 1, col="darkgray", lwd=1.5, lty=1)
}
dev.off()

```

### maf 

For a given list of SNPs, We computed their correlations with distant SNPs, i.e., $\overline{r^2_j}$, using SNPs with a MAF < 0.1 and ones with a MAF > 0.1. We did it in a systematic way.

1. maf: < .1 vs. > .1.
2. level of confounding: 0k, 1k, 2k, ..., 6k.
3. number of distant SNPs: 1k, 5k, 10k, 20k.

#### 1st run

```{bash eval=F}
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# compute maf of mix pops
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# script file

for n in {0k,1k,2k,3k,4k,5k,6k}; do

if [ $n == 0k ]; then
  id=../rand.100000
else
  id=../mix-pop-gwas-$n-noneuro.id
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --calc-stats ../gen/maf/geno-mix-$n-noneuro-stats \
          --bfile ../gen/geno-mix-maf.001 \
          --keep $id
"> sh_script/calc-maf-$n-noneuro.sh
done

# submit script
for n in {0k,1k,2k,3k,4k,5k,6k}; do
sbatch -A snpher ../sh_script/calc-maf-$n-noneuro.sh
done>../job-records/calc-maf

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# SNP lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# lista (1k): fixed for all analyses
# chosen from chrom 1-7. maf > 0.01

dir=inflation/sensitivity/maf.1
awk '{split($1, a, ":"); 
    if (a[1]<8 && $5>0.1 && $6>=0.95) 
    print $1}' gen/geno-mix-maf.001.stats | shuf | head -n 1000 > $dir/lista-1k

# listb
# this will vary depending on the mix pop
dir=inflation/sensitivity/maf.1/listb
m=(1000 5000 10000 20000)
nm=(1k 5k 10k 20k)

for n in {0k,1k,2k,3k,4k,5k,6k}; do
for i in {0..3}; do
infile=gen/maf/geno-mix-$n-noneuro-stats.stats
# maf > 0.1
awk '{split($1, a, ":"); 
    if (a[1]>=8 && $5>=0.1 && $6>=0.95) 
    print $1}' $infile | shuf | head -n ${m[$i]} > $dir/listb-maf-g.1-${nm[$i]}-snps-mix-pop-$n-noneuro 
# maf < 0.1
awk '{split($1, a, ":"); 
    if (a[1]>=8 && $5>0.01 && $5<0.1 && $6>=0.95) 
    print $1}' $infile | shuf | head -n ${m[$i]} > $dir/listb-maf-l.1-${nm[$i]}-snps-mix-pop-$n-noneuro  
done
done

# actually it is easier to create pool of the right for maf > .1 & maf<.1.
# then we can choose a completely different listb for another run. So let's do that
dir=inflation/sensitivity/maf.1/listb
for n in {0k,1k,2k,3k,4k,5k,6k}; do
infile=gen/maf/geno-mix-$n-noneuro-stats.stats
# maf > 0.1
awk '{split($1, a, ":"); 
    if (a[1]>=8 && $5>=0.1 && $6>=0.95 && NR >1 ) 
    print $1}' $infile > $dir/right-maf-g.1-mix-pop-$n-noneuro 
# maf < 0.1
awk '{split($1, a, ":"); 
    if (a[1]>=8 && $5>0.01 && $5<0.1 && $6>=0.95 && NR >1) 
    print $1}' $infile > $dir/right-maf-l.1-mix-pop-$n-noneuro  
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# compute r_ij using ldak-------------------------------------------------------

dir=../inflation/sensitivity/maf.1
bfile=../gen/geno-mix-maf.001

for n in {0k,1k,2k,3k,4k,5k,6k}; do
for m in {1k,5k,10k,20k}; do
for j in {g.1,l.1}; do

# define vars
lista=$dir/lista-1k
listb=$dir/listb/listb-maf-$j-$m-snps-mix-pop-$n-noneuro
out=$dir/out/maf-$j-$m-snps-mix-pop-$n-noneuro

if [ $n == 0k ]; then
  id=../rand.100000
else 
  id=../mix-pop-gwas-$n-noneuro.id
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 3 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-cor-maf-$j-$m-snps-mix-pop-$n-noneuro
done
done
done

# submit jobs
for n in {0k,1k,2k,3k,4k,5k,6k}; do
for m in {1k,5k,10k,20k}; do
for j in {g.1,l.1}; do
sbatch -A snpher ../sh_script/calc-cor-maf-$j-$m-snps-mix-pop-$n-noneuro
done
done
done>../job-records/calc-r-sensitivity

# compute ave r^2_j using R-----------------------------------------------------
R
require(vroom)
n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
m=c("1k","5k", "10k", "20k")
m_num=c(1000,5000, 10000,20000)
l=c("g.1","l.1")
dir="inflation/sensitivity/maf.1/"

for(j in 1:length(m)){
for(k in 1:length(l)){
  for(i in 1:length(n)){
    
    nm=paste0("maf-",l[k],"-",m[j],"-snps-mix-pop-",n[i],"-noneuro")
    dat=vroom(paste0(dir,"out/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0(dir,"out/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0(dir,"out/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(m_num[j]+1)]^2
    out=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    write.table(out,paste0(dir,"summary/ave-r2-",nm), col.names=F, row.names=F, quote=F)
  }
}
}

```

#### 2st run

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# SNP lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# listb
# we want to generate a completely different listb

dir1=inflation/sensitivity/maf.1/listb
dir2=inflation/sensitivity/maf.1/listb-run2
m=(1000 5000 10000 20000)
nm=(1k 5k 10k 20k)

for n in {0k,1k,2k,3k,4k,5k,6k}; do
for i in {0..3}; do

# right snp list based on dif. mix pop. i.e., our pools to draw snps
pool1=$dir1/right-maf-g.1-mix-pop-$n-noneuro
pool2=$dir1/right-maf-l.1-mix-pop-$n-noneuro

# list b for run #1
old1=$dir1/listb-maf-g.1-${nm[$i]}-snps-mix-pop-$n-noneuro
old2=$dir1/listb-maf-l.1-${nm[$i]}-snps-mix-pop-$n-noneuro 

# new list b for run #2
new1=$dir2/listb-maf-g.1-${nm[$i]}-snps-mix-pop-$n-noneuro
new2=$dir2/listb-maf-l.1-${nm[$i]}-snps-mix-pop-$n-noneuro 

# maf > 0.1
awk 'NR==FNR {a[$1]; next} 
     !($1 in a) {print $1}' $old1 $pool1 | shuf | head -n ${m[$i]} > $new1
    
# maf < 0.1
awk 'NR==FNR {a[$1]; next} 
     !($1 in a) {print $1}' $old2 $pool2 | shuf | head -n ${m[$i]} > $new2 
done
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# compute r_ij using ldak-------------------------------------------------------

dir=../inflation/sensitivity/maf.1
bfile=../gen/geno-mix-maf.001

for n in {0k,1k,2k,3k,4k,5k,6k}; do
for m in {1k,5k,10k,20k}; do
for j in {g.1,l.1}; do

# define vars
lista=$dir/lista-1k
listb=$dir/listb-run2/listb-maf-$j-$m-snps-mix-pop-$n-noneuro
out=$dir/out-run2/maf-$j-$m-snps-mix-pop-$n-noneuro

if [ $n == 0k ]; then
  id=../rand.100000
else 
  id=../mix-pop-gwas-$n-noneuro.id
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 3 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-cor-maf-$j-$m-snps-mix-pop-$n-noneuro
done
done
done

# submit jobs
for n in {0k,1k,2k,3k,4k,5k,6k}; do
for m in {1k,5k,10k,20k}; do
for j in {g.1,l.1}; do
sbatch -A snpher ../sh_script/calc-cor-maf-$j-$m-snps-mix-pop-$n-noneuro
done
done
done>../job-records/calc-r-sensitivity-run2

# compute ave r^2_j using R-----------------------------------------------------
R
require(vroom)
n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
m=c("1k","5k", "10k", "20k")
m_num=c(1000,5000, 10000,20000)
l=c("g.1","l.1")
dir="inflation/sensitivity/maf.1/"

for(j in 1:length(m)){
for(k in 1:length(l)){
  for(i in 1:length(n)){
    
    nm=paste0("maf-",l[k],"-",m[j],"-snps-mix-pop-",n[i],"-noneuro")
    dat=vroom(paste0(dir,"out-run2/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0(dir,"out-run2/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0(dir,"out-run2/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(m_num[j]+1)]^2
    out=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    write.table(out,paste0(dir,"summary-run2/ave-r2-",nm), col.names=F, row.names=F, quote=F)
  }
}
}

```

### summary

Here we check the alignment between 1st and 2nd run under different settings.

```{r eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# 1st run vs. 2nd run
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
m=c("1k","5k", "10k", "20k")
dir="inflation/sensitivity/maf.1/"

png("fig/ave-r2-1st-vs-2nd-run.png", res=600, width=40, height=70, units="cm")
par(mfrow=c(7,4), pty="s")

for(i in 1:length(n)){
  for(j in 1:length(m)){
    
    nm1=paste0("maf-g.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf > .1
    nm2=paste0("maf-l.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf < .1
    
    dat1.1=read.table(paste0(dir,"summary/ave-r2-",nm1),stringsAsFactors = F)
    dat2.1=read.table(paste0(dir,"summary-run2/ave-r2-",nm1),stringsAsFactors = F)
    dat1.2=read.table(paste0(dir,"summary/ave-r2-",nm2),stringsAsFactors = F)
    dat2.2=read.table(paste0(dir,"summary-run2/ave-r2-",nm2),stringsAsFactors = F)
    
    start=min(c(dat1.1$V2,dat1.2$V2,dat2.1$V2,dat2.2$V2))
    end=max(c(dat1.1$V2,dat1.2$V2,dat2.1$V2,dat2.2$V2))
    
      plot(dat1.1$V2, dat2.1$V2,
           xlim=c(start,end), ylim=c(start, end),
           xlab="1st run", ylab="2nd run", 
           main=paste0(m[j]," snps"," ",n[i]," non-european"), las=1,
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
      points(dat1.2$V2, dat2.2$V2,
           cex = 1.5, pch=21, col="white", bg="orange", lwd=0.5)
      abline(0, 1, col="darkgray", lwd=1.5, lty=1)
      
      if(i==1 & j==1) {legend("topleft", pch=19, legend=c("maf > .1","maf < .1"), 
             col=c("darkgray", "orange"), cex=1.5, box.lty=0)}
  }
}
dev.off()

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# maf > .1 vs. maf < .1
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
m=c("1k","5k", "10k", "20k")
dir="inflation/sensitivity/maf.1/"

png("fig/ave-r2-maf-g.1-vs-l.1.png", res=600, width=40, height=70, units="cm")
par(mfrow=c(7,4), pty="s")

for(i in 1:length(n)){
  for(j in 1:length(m)){
    
    nm1=paste0("maf-g.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf > .1
    nm2=paste0("maf-l.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf < .1
    
    dat1.1=read.table(paste0(dir,"summary/ave-r2-",nm1),stringsAsFactors = F)
    dat1.2=read.table(paste0(dir,"summary/ave-r2-",nm2),stringsAsFactors = F)
    dat2.1=read.table(paste0(dir,"summary-run2/ave-r2-",nm1),stringsAsFactors = F)
    dat2.2=read.table(paste0(dir,"summary-run2/ave-r2-",nm2),stringsAsFactors = F)
    
    start=min(c(dat1.1$V2,dat1.2$V2,dat2.1$V2,dat2.2$V2))
    end=max(c(dat1.1$V2,dat1.2$V2,dat2.1$V2,dat2.2$V2))
    
      plot(dat1.1$V2, dat1.2$V2,
           xlim=c(start,end), ylim=c(start, end),
           xlab="maf > .1", ylab="maf < .1", 
           main=paste0(m[j]," snps"," ",n[i]," non-european"), las=1,
           cex = 1.5, pch=21,  bg="lightgray", col="white", lwd=0.5)
      points(dat2.1$V2, dat2.2$V2,
           cex = 1.5, pch=21, col="white", bg="orange", lwd=0.5)
      abline(0, 1, col="darkgray", lwd=1.5, lty=1)
      
      if(i==1 & j==1) {legend("topleft", pch=19, legend=c("1st run","2nd run"), 
             col=c("lightgray", "orange"), cex=1.5, box.lty=0)}
  }
}
dev.off()

```


```{r aver2-alignment-by-run, fig.cap='robustness of ave r2_j: 1st run vs. 2nd run', fig.show='hold', out.width='100%', fig.asp=0.75, fig.align='left', echo=F}
knitr::include_graphics(c("fig-to-insert/ave-r2-1st-vs-2nd-run.png"))
```


```{r aver2-alignment-by-maf, fig.cap='robustness of ave r2_j: maf > .1 vs. maf < .1', fig.show='hold', out.width='100%', fig.asp=0.75, fig.align='left', echo=F}
knitr::include_graphics(c("fig-to-insert/ave-r2-maf-g.1-vs-l.1.png"))
```


```{r eval=F}

n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
m=c("1k","5k", "10k", "20k")
dir="inflation/sensitivity/maf.1/"

png("fig/ave-r2-1st-vs-2nd-run.png", res=600, width=40, height=70, units="cm")
par(mfrow=c(7,4), pty="s")

for(i in 1:length(n)){
  for(j in 1:length(m)){
    
    nm1=paste0("maf-g.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf > .1
    nm2=paste0("maf-l.1-",m[j],"-snps-mix-pop-",n[i],"-noneuro") # maf < .1
    
    dat1.1=read.table(paste0(dir,"summary/ave-r2-",nm1),stringsAsFactors = F)
    dat2.1=read.table(paste0(dir,"summary-run2/ave-r2-",nm1),stringsAsFactors = F)
    dat1.2=read.table(paste0(dir,"summary/ave-r2-",nm2),stringsAsFactors = F)
    dat2.2=read.table(paste0(dir,"summary-run2/ave-r2-",nm2),stringsAsFactors = F)
    
    test1=cor.test(dat1.1$V2, dat2.1$V2)
    test2=cor.test(dat1.2$V2, dat2.2$V2)
    
    out1.0=data.frame(maf=">.1",
                      n_noneuro=n[i],
                      m=m[j],
                      est=test1$estimate,
                      low_95=test1$conf.int[1],
                      up_95=test1$conf.int[2], stringsAsFactors = F)
    out2.0=data.frame(maf="<.1",
                      n_noneuro=n[i],
                      m=m[j],
                      est=test2$estimate,
                      low_95=test2$conf.int[1],
                      up_95=test2$conf.int[2], stringsAsFactors = F)
      
      if(i==1 & j==1){
        out1.1=out1.0; 
        out2.1=out2.0
      }else{
          out1.1=rbind(out1.1,out1.0)
          out2.1=rbind(out2.1,out2.0)
         }
  }
}

```

## varying levels of confouding

3. Show that estimated inflation correlates well with difference in $\overline{r_j^2}$ between bad and good GWAS.
I guess it will be nice to have more variety. E.g., instead of good and bad, have good, a bit bad (e.g., 1000 non-europeans), a bit more bad (2000 non-europeans), ... bad (7000 non-europeans).

Would be great to know the slope of this regression. Can you estimate it by regressing $S_j$ on $\overline{r_j^2}$ from the bad GWAS? But if we can, we just say the slope is less than n

You showed that if you regress inflation on $\overline{r_j^2}$ and MAF, that MAF is not significant (nor if you use log(MAF) or exp(MAF) or (MAFX(1-MAF))).
Can you also include info score - hopefully this is also not significant.
If Maf and Info scores are redundant, this strengthens argument for using r2j

So we ran the bad GWASs once again using different number of Europeans (n1) & Non-europeans (n2) while keep N = n1+n2=100. We did so for different MAF. For these GWASs, we regress the chi square test statistics on $\overline{r_j^2}$, MAF & info score.

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# create directories
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

for i in 0k 1k 2k 3k 4k 5k 6k; do
mkdir gwas-mix-$i-noneuro
done
# note: previously, the mixed population GWAS was based on 6,472 non-europeans 
for i in 0k 1k 2k 3k 4k 5k 6k; do
for j in .1 .01 .001; do
mkdir gwas-mix-$i-noneuro/maf$j
done
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# create id lists & snp lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# id lists---------------------------------------------------------------------
# note we used id lists from previous bad GWAS

# noneuropean id  
cat relatedness/asian-cut.05.keep relatedness/black-cut.05.keep > noneuro-unrel.id

# mixed pop id
n1=(1000 2000 3000 4000 5000 6000)
nm=(1k 2k 3k 4k 5k 6k)
n2=(99000 98000 97000 96000 95000 94000)

for i in {0..5}; do
shuf noneuro-unrel.id | head -n ${n1[$i]} > noneuro-unrel.rand.${n1[$i]}
shuf rand.100000 | head -n ${n2[$i]} > white-unrel.rand.${n2[$i]}
cat white-unrel.rand.${n2[$i]} noneuro-unrel.rand.${n1[$i]} > mix-pop-gwas-${nm[$i]}-noneuro.id
done

# snp list----------------------------------------------------------------------
# note: for the initial bad gwas, we used the snp list for good gwas
# i.e., ../gen/snps-unrel-inds.use
# gen/geno-unrel.stats is based on QCed genotype data of rand.100000 before maf...
# ... call-rate screening 

# here we want to get snp list of different maf thresholds
for maf in .1 .01 .001; do
awk < gen/geno-unrel.stats -v maf=$maf '($5>maf && $6>=0.95 && NR>1){print $1}' > gen/snps-unrel-maf$maf.use
wc -l gen/snps-unrel-maf$maf.use
done

# maf > 0.1 : 856,746 snps-unrel-maf.1.use
# maf > 0.01 : 1,103,209 snps-unrel-maf.01.use
# maf > 0.001 : 1,111,494 snps-unrel-maf.001.use

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  extract genotype data for mixed pop
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# note: previously geno-mix is based on snps-unrel-inds.use, which is a snp list...
#... after filtering for maf (maf>0.01) and call rate. So genotype data does not...
#... contain snps with maf < 0.01. So we need to extract genotype data for this...
#... set of analysis using overlap-mixed-complete-cov.id and snps-unrel-maf.001.use...
#...(see above for how the snp list is generated)

# bfiles by chr-----------------------------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../overlap-mixed-complete-cov.id \
         --extract ../gen/snps-unrel-maf.001.use \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-mix \
         --threads 3 \
"> sh_script/chr$j-mix.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i-mix.sh
done>../job-records/mkbfile-mix-pop-new

# merge bfiles------------------------------------------------------------------
rm bfile-mix-new.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-mix" >>bfile-mix-new.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 10:0:0
./ldak5.1 --make-bed ../gen/geno-mix-maf.001 \
          --mbfile ../gen/bfile-mix-new.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/merge-mbfiles-mix.sh

# submit the script
sbatch -A snpher ../sh_script/merge-mbfiles-mix.sh >../job-records/merge-mbfiles-mix-pop-maf.001

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  get INFO score
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# here we repeat the QC step for the good gwas to compute the INFO score
# note: since the MAF is based on snp list after QC for rand.100000, here we compute...
#...INFO based on the same list of participants.

# make QCed pgen files---------------------------------------------------------- 
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../unrelated/rand.100000 \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-pgen \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-unrel \
         --threads 3
"> sh_script/chr$j.sh
done

# submit jobs
for j in {1..22}; do
sbatch -A snpher ../sh_script/chr$j.sh
done > ../job-records/qc-unrel-pgen

# compute info score------------------------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/tmp/bhr$j-unrel \
         --keep ../unrelated/rand.100000 \
         --threads 3 \
         --memory 20000 \
         --freq cols=chrom,ref,alt,altfreq,machr2 \
         --out ../gen/info/chr$j 
        
"> sh_script/info-chr$j.sh
done

# submit file
for j in {1..22}; do
sbatch -A snpher ../sh_script/info-chr$j.sh
done > ../job-records/compute-info-score

# combine files
dir=gen/info
rm $dir/rand.100000-qced-afreq 
for i in {1..22}; do
if [ $i == 1 ]; then
  awk '{print $0}' $dir/chr$i.afreq > $dir/rand.100000-qced.afreq
else 
  awk 'NR>1 {print $0}' $dir/chr$i.afreq >> $dir/rand.100000-qced.afreq
fi
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# GWASs
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## NOTE: for maf >0.001, we will have to redo the GWAS, because geno-mix only ...
#...contains snps with maf > 0.01. See below

# for 0k, i.e., the good gwas without PC as covariates--------------------------------------
n=0k
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for maf in {.1,.01,.001}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 7G
#SBATCH -c 2
#SBATCH -t 2:00:0

./ldak5.1 --linear ../gwas-mix-$n-noneuro/maf$maf/$i-linear \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-mix \
          --covar ../phen/basic-covariates.use \
          --keep ../rand.100000 \
          --extract ../gen/snps-unrel-maf$maf.use \
          --max-threads 2
"> sh_script/$i-linear-$n-noneuro-maf-$maf.sh
done
done

# submit files------------------------------------------------------------------
n=0k
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for maf in {.1,.01,.001}; do
sbatch -A snpher ../sh_script/$i-linear-$n-noneuro-maf-$maf.sh
done
done>../job-records/bad-gwas-0k-noneuro

# for 1k to 6k------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for n in {1k,2k,3k,4k,5k,6k}; do
for maf in {.1,.01,.001}; do
#for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 7G
#SBATCH -c 2
#SBATCH -t 8:00:0

./ldak5.1 --linear ../gwas-mix-$n-noneuro/maf$maf/$i-linear \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-mix \
          --covar ../phen/basic-covariates.use \
          --keep ../mix-pop-gwas-$n-noneuro.id \
          --extract ../gen/snps-unrel-maf$maf.use \
          --max-threads 2
"> sh_script/$i-linear-$n-noneuro-maf-$maf.sh
done
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for n in {1k,2k,3k,4k,5k,6k}; do
for maf in {.1,.01,.001}; do
#for j in {1..22}; do
sbatch -A snpher ../sh_script/$i-linear-$n-noneuro-maf-$maf.sh
done
done
done>../job-records/bad-gwas

# check job completion
file=job-records/bad-gwas
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# combine results for some--------------------------------------------------- 
# only for .summaries & .pvalues
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,quals,pulse,reaction,sbp,snoring,hyper}; do 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-chr-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-chr-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-chr-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-chr-$j.pvalues >> $i-linear.pvalues
fi
done
done

# repeat gwas for maf>.001 -----------------------------------------------------
maf=.001
bfile=../gen/geno-mix-maf.001
n=(0k 1k 2k 3k 4k 5k 6k)

for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {0..6}; do

out=../gwas-mix-${n[$j]}-noneuro/maf$maf/$i-linear

if [ $j == 1 ]; then
  id=../rand.100000
else
  id=../mix-pop-gwas-${n[$j]}-noneuro.id
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 7G
#SBATCH -c 2
#SBATCH -t 01:30:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --covar ../phen/basic-covariates.use \
          --keep $id \
          --extract ../gen/snps-unrel-maf$maf.use \
          --max-threads 2
"> sh_script/$i-linear-${n[$j]}-noneuro-maf-$maf.sh
done
done

# submit files------------------------------------------------------------------
maf=.001
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for n in {0k,1k,2k,3k,4k,5k,6k}; do
sbatch -A snpher ../sh_script/$i-linear-$n-noneuro-maf-$maf.sh
done
done>../job-records/bad-gwas


#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# create snp lists--------------------------------------------------------------

# note: we do this for three snp lists
# maf > 0.1 : 856,746 gen/snps-unrel-maf.1.use
# maf > 0.01 : 1,103,209 gen/snps-unrel-maf.01.use
# maf > 0.001 : 1,111,494 gen/snps-unrel-maf.001.use

m=10000
nm=10k

for i in {.1,.01,.001}; do
# define vars
infile=gen/snps-unrel-maf$i.use
left=inflation/left-snps-unrel-maf$i-$nm
right=inflation/right-snps-unrel-maf$i-$nm

awk '{split($1, a, ":");
    if (a[1]<8) print $1 }' $infile | shuf | head -n $m >$left  
awk '{split($1, a, ":");
    if (a[1]>=8) print $1 }' $infile | shuf | head -n $m >$right
done

# compute r_ij using ldak -------------------------------------------------------

n=(0k 1k 2k 3k 4k 5k 6k)
indir=../inflation
outdir=../inflation/out
bfile=../gen/geno-mix-maf.001

for j in {0..6}; do
for i in {.1,.01,.001}; do

# define vars
lista=$indir/right-snps-unrel-maf$i-10k
listb=$indir/left-snps-unrel-maf$i-10k
out=$outdir/10k-snps-mix-pop-gwas-${n[$j]}-noneuro-maf$i

if [ $j == 0 ]; then
  id=../rand.100000
else 
  id=../mix-pop-gwas-${n[$j]}-noneuro.id
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 10
#SBATCH -t 2:00:0
./ldak5.2 --max-threads 10 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-mix-pop-gwas-${n[$j]}-noneuro-maf$i
done
done

# submit the job
n=(0k 1k 2k 3k 4k 5k 6k)
for j in {0..6}; do
for i in {.1,.01,.001}; do
sbatch -A snpher ../sh_script/calc-r-10k-snps-mix-pop-gwas-${n[$j]}-noneuro-maf$i
done
done>../job-records/calc-r

#  compute ave r_j^2 for each i-------------------------------------------------
R
require(vroom)
n=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
maf=c(".1",".01",".001")

for(j in 1:length(maf)){

  for(i in 1:length(n)){
    nm=paste0("10k-snps-mix-pop-gwas-",n[i],"-noneuro-maf",maf[j])
    dat=vroom(paste0("inflation/out/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0("inflation/out/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0("inflation/out/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(10001)]^2
    outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
    outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    out=rbind(outa,outb)
    
    write.table(out,paste0("summary/ave-r2-",nm), col.names=F, row.names=F, quote=F)  
  }
}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# extract LD score
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# convert snp list to rs system ------------------------------------------------
infile=gen/snps-unrel-maf.001.use
outfile=gen/snps-unrel-maf.001.use-rs
awk '(NR==FNR){a[$1]; b[$1]=$2; next}
     ($1 in a){print b[$1], $2}' doug/ukbb.ldsc $infile > $outfile

#  extract ld scores -----------------------------------------------------------
dir=ldsc/eur_w_ld_chr
for chrom in {1..22}; do
zcat $dir/$chrom.l2.ldscore.gz | awk 'NR>1 {print $2, $6}' > ldscore
awk '(NR==FNR){a[$1];next}($1 in a){print $0}' gen/snps-unrel-maf.001.use-rs ldscore > temp
if [ $chrom -eq 1 ]
then 
 mv temp snps-unrel-maf.001.ldscore
else
 cat snps-unrel-maf.001.ldscore temp > temp2
 mv temp2 snps-unrel-maf.001.ldscore
fi
echo $chrom
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  put info together
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# INFO: gen/info rand.100000-qced.afreq 
# maf: gen/geno-mix-maf.001.stats
# chi square : trait-linear.summaries
# ave r^2_j: e.g, summary/ave-r2-10k-snps-mix-pop-gwas-$i-noneuro-maf$j
# ld score from ldsc ref panel: snps-unrel-maf.001.ldscore; in rs

# required files
maf=gen/geno-mix-maf.001.stats # use as the snp list to integrate all info
info=gen/info/rand.100000-qced.afreq
rs=doug/ukbb.ldsc
ldsc=snps-unrel-maf.001.ldscore

# temporary files
awk 'NR > 1 {print $1, $5 }' $maf > tmp/maf.tmp
awk 'NR==FNR {a[$2]; b[$2]=$6; next} 
              {if ($1 in a) print b[$1] ;
               else print "NA"}' $info tmp/maf.tmp  > tmp/info.tmp
awk 'NR==FNR {a[$2]; b[$2]=$1; next} ($1 in a) {print b[$1], $0}' $rs $ldsc > tmp/ldsc.tmp1
# here we make sure the order of the rows are the same as maf.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; c[$1]=$3 ; next} 
     {if ($1 in a) print b[$1], c[$1];
      else print "NA"}' tmp/ldsc.tmp1 tmp/maf.tmp > tmp/ldsc.tmp

for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for n in {0k,1k,2k,3k,4k,5k,6k}; do
for j in {.1,.01,.001}; do

# define files
gwas=gwas-mix-$n-noneuro/maf$j/$trait-linear.summaries
aver2=summary/ave-r2-10k-snps-mix-pop-gwas-$n-noneuro-maf$j
out=gwas-mix-all-out/$trait-mix-pop-gwas-$n-noneuro-maf$j.out

# create temporary files
awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/maf.tmp > tmp/aver2.tmp
     
awk 'NR==FNR {a[$1]; b[$1]=$5; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $gwas tmp/maf.tmp > tmp/gwas.tmp     

# put info together
paste tmp/maf.tmp \
      tmp/info.tmp \
      tmp/gwas.tmp \
      tmp/aver2.tmp \
      tmp/ldsc.tmp \
      | awk 'BEGIN{OFS=";";print "snp;maf;info;chisq;aver2;rs;ldsc"}
              {$1=$1}1' > $out
done
done
done

```

## results summary
```{r eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

# function to plot a single trait---------------------------------------------------

make_plot=function(trait, maf, n_noneuro){
  
  # define variables
  n_noneuro=n_noneuro
  trait=trait
  maf=maf
  
  # define color
  library(RColorBrewer)
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  set.seed(14)
  mycol=sample(col_vector,7)
  
  # plot
  for(i in length(n_noneuro):1){
    n=n_noneuro[i]
    file=paste0("gwas-mix-all-out/",trait,"-mix-pop-gwas-",n,
                "-noneuro-maf",maf,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
    out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
    
    if(i==length(n_noneuro)){
    plot(out$bin_val, out$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg=mycol[i], col="white", lwd=0.5)
    } else {
      points(out$bin_val, out$chisq_ave,
           cex = 1.5, pch=21, col="white", bg=mycol[i], lwd=0.5)
    } # end of conditional statement
  } # end of loop over n
   # add a legend
  
   if(trait=="awake"){
     legend("topleft", pch=19, legend=n_noneuro, col=mycol, cex=1.5, box.lty=0)}
   
} # end of function

# make a plot ------------------------------------------------------------------

# maf = .01----------------------------
require(vroom)
n_noneuro=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
maf_threshold=c(".1",".01",".001")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

maf=maf_threshold[2]

png(paste0("fig/mix-pop-gwas-chisq-by-aver2-bin.png"),
    width = 50, height = 30, units = "cm", res=600)
par(mfrow=c(3,5))
    for(i in 1:length(traits)){
      trait=traits[i]
      make_plot(trait, maf, n_noneuro)
    }
dev.off()

# maf = .001----------------------------
require(vroom)
n_noneuro=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
maf_threshold=c(".1",".01",".001")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

maf=maf_threshold[3]

png(paste0("fig/mix-pop-gwas-chisq-by-aver2-bin-maf.001.png"),
    width = 50, height = 30, units = "cm", res=600)
par(mfrow=c(3,5))
    for(i in 1:length(traits)){
      trait=traits[i]
      make_plot(trait, maf, n_noneuro)
    }
dev.off()

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)
n_noneuro=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
maf_threshold=c(".1",".01",".001")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(maf_threshold)){
  for(j in 1:length(n_noneuro)){
    for(k in 1:length(traits)){

    maf=maf_threshold[i]
    n=n_noneuro[j]
    trait=traits[k]
    
    file=paste0("gwas-mix-all-out/",trait,"-mix-pop-gwas-",n,
                    "-noneuro-maf",maf,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod1=lm(chisq ~ aver2,data=dat)
    mod2=lm(chisq ~ ldsc,data=dat)
    
    slope0=data.frame(trait=trait,
                      maf_threshold=maf,
                      n_noneuro=n,
                      slope_aver2=coef(mod1)[2],
                      p_aver2=summary(mod1)$coefficients[,4][2],
                      slope_ldsc=coef(mod2)[2],
                      p_ldsc=summary(mod2)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1 & j==1 & k==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
    }
  }
}

out=slope[order(slope$trait, slope$maf_threshold, slope$n_noneuro),]
write.table(out,"summary/mix-pop-gwas-slope.txt", col.names=T, row.names=F, quote=F)

```

```{r eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j by maf | n_noneuro
#::::::::::::::::::::::::::::::::::::::::::::::

# function to plot a single trait---------------------------------------------------

make_plot=function(trait, maf_threshold, n){
  
  # define variables
  n=n
  trait=trait
  maf_threshold=maf_threshold
  
  # define color
  library(RColorBrewer)
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  set.seed(14)
  mycol=sample(col_vector,length(maf_threshold))
  
  # plot
  for(i in 1:length(maf_threshold)){
    maf=maf_threshold[i]
    file=paste0("gwas-mix-all-out/",trait,"-mix-pop-gwas-",n,
                "-noneuro-maf",maf,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
    out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
    
    if(i==1){
    plot(out$bin_val, out$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         main=paste0(trait," ", n," non-european"), las=1,
         cex = 1.5, pch=21,  bg=mycol[i], col="white", lwd=0.5)
    } else {
      points(out$bin_val, out$chisq_ave,
           cex = 1.5, pch=21, col="white", bg=mycol[i], lwd=0.5)
    } # end of conditional statement
  } # end of loop over maf
   # add a legend
   if(trait=="awake"){
     legend("topleft", pch=19, legend=maf_threshold, col=mycol, cex=1.5, box.lty=0)}
   
} # end of function

# make a plot ------------------------------------------------------------------

require(vroom)
n_noneuro=c("0k","1k", "2k", "3k", "4k", "5k", "6k")
maf_threshold=c(".1",".01",".001")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:length(n_noneuro)){
  
  n=n_noneuro[j]
  # plot give an n for non-european
  png(paste0("fig/mix-pop-gwas-chisq-by-aver2-bin-",n,"-noneuro.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
      for(i in 1:length(traits)){
        trait=traits[i]
        make_plot(trait, maf_threshold, n)
      }
  dev.off()
}

```



We can now report average inflation of test statistics (mean(r2j) x n x h2, which is upper bounded by mean(r2j) x n), AND we can report estimated per-SNP inflation of test statistics (r2j x n x j2)

Eg., we can say that if you use UKBB recommended samples, with MAF>.01, the average inflation will be less than 0.5 units, while the maximum inflation will be less than 1 unit.

However, maybe we find that if you analyse rare SNPs (e.g. 0.0001 < MAF < .01), the maximum inflation is much higher (so people must be careful).

What happens if you have a meta-analysis - how does inflation accumulate over cohorts?


Possible way to write up this paper:

Perform a good and bad GWAS of height

Figure 1a - show that GIF performs poorly (because test statistics of good GWAS do not follow a chisq(1) distribution)

Figure 1b - use test statistics of good GWAS to show that LDSC performs badly, because it assumes causal variation is constant [Do you mean the choice of heritability model affects inflation estimates? But we found for good GWASs, ldsc under gcta is OK for most traits.]

Figure 1c - use difference between test statistics to show that LDSC performs badly because it assumes inflation is constant.

(in supplement, can show same results for other traits).

Figure 2 - show that r2j is independent of true signal (test statistics from good gwas), but predicts well inflation (difference)
