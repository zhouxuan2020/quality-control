
# Good GWAS {#good}

Here we do good GWASs. We will use 1.2M hapmap3 SNPs.
But sill need to do some QC to these SNPs.

## QC of hp3 SNPs {#goodid}
```{bash eval=F}

# select 100k unrelated individuals with no missing covariates & 14 phenotypes--

# individual with complete covariates
R
options(scipen = 100)
library(vroom)
dat=vroom("phen/covariates.use", col_names=F)
out=dat[complete.cases(dat),c(1,2)]
write.table(out,"covariates-complete-cases.id", col.names=F, row.names=F, quote=F)

# overlaping individuals across 14 traits
cp icd10/unrelated.inds overlap.ind # unrelated white British

dir=phen/continuous-traits/
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv overlap.ind temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' temp $dir/$tt.raw.pheno > overlap.ind
wc -l overlap.ind
echo $tt
done
rm temp

# overlapping & complete covariates
awk 'NR==FNR{a[$1]; next} ($1 in a) {print $1, $1}' overlap.ind covariates-complete-cases.id > overlap-complete-cases.id

#randomly pick 100k of these
shuf overlap-complete-cases.id | head -n 100000 > rand.100000

# QC SNPs-----------------------------------------------------------------------
# stating number of SNPs= 1,184,423 
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../unrelated/rand.100000 \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-unrel \
         --threads 3
"> sh_script/chr$j.sh
done

# submit jobs
for j in {1..22}; do
sbatch -A snpher ../sh_script/chr$j.sh
done > ../job-records/qc-unrel

# merge files
rm bfile-unrel.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-unrel" >>bfile-unrel.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 40:0:0
./ldak5.1 --make-bed ../gen/geno-unrel \
          --mbfile ../gen/bfile-unrel.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/mbfile-unrel.sh

# submit the script
sbatch -A snpher ../sh_script/mbfile-unrel.sh >../job-records/mbfiles-unrel

# MAF & call-rate 
awk < geno-unrel.stats '($5>.01 && $6>=0.95 && NR>1){print $1}' > snps-unrel-inds.use
# m = 1,103,209 SNPs
 
```

## extract covariates

```{R eval=F}

head=read.table("phen/ukb45861.header", sep=",", header=F, stringsAsFactors = F)
# function to get the variables
get=function(nm){
  colnum=grep(nm,head,fixed=TRUE)
  out=data.frame(t(rbind(colnum, head[,colnum])))
  names(out)=c("column", "field")
  return (out)
}
# get the variables
out=rbind(get('21022-0'), # age at recruitment: 21022
          get('54-0'), # assessment centre: 54
          get('22000-0'), # genotyping batch: 22000
          get('22001-0'), # genetic sex: 22001
          get('189-0'), # townsend
          get('22009-0'), # genotype PC: 22009
          get('21000-0')) # ethnic background 
row.names(out)=1:dim(out)[1]
# remove unwanted
out=out[-c(95:100),]
write.table(out,"phen/covariates.colnum", col.names=F, row.names=F, sep="\t", quote=F)

# extract dat from the full data set
awk -F '","' '(NR==FNR){a[$1];next}{printf "%s\"", $1;for(i in a){printf " \"%s\"", $i};printf "\n"}' phen/covariates.colnum phen/ukb45861.csv > phen/covariates.dat

#--------
# organize covariates
#--------

options(scipen = 100)
# all covariates
var=read.table("phen/covariates.dat", header=T, stringsAsFactors = F)
nm=names(var)

# extract covariates
var1=data.frame(eid=var$eid,
                age=var[,grep('21022', nm, fixed=T)], # age at recruitment
                sex_gen=var[,grep('22001', nm, fixed=T)], # genetic sex: 0 =F; 1 = M
                centre=var[,grep('X54', nm, fixed=T)], # assessment centre
                geno_batch=var[,grep('22000', nm, fixed=T)], # genotype batch
                townsend=var[,grep('189', nm, fixed=T)], # townsen
                var[,grep('22009', nm, fixed=T)], # genotype PC
                ethnicity=var[,grep('21000', nm, fixed=T)], # self-reported ethnicity
                stringsAsFactors = F)
pcnm=strsplit(nm[grep('22009', nm, fixed=T)], "[.]")
pcnm=paste0("pc",unlist(lapply(pcnm,function(X) X[3])))
names(var1)[7:46]=pcnm

# file that contains all covariates
write.table(var1,"phen/covariates.phen", col.names=T, row.names=F, quote=F)

# create a file to use: no col.names & continuous covariates only
use=var1[,c(1,1:3,6:46)]
write.table(names(use),"phen/covariates.use-names", 
            col.names=F, row.names=F, quote=F)
write.table(use,"phen/covariates.use", col.names=F, row.names=F, quote=F)
```


## GWAS

```{bash eval=F}

# linear regression-------------------------------------------------------------
mkdir unrelated/gwas-good
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 2
#SBATCH -t 10:0:0

./ldak5.1 --linear ../unrelated/gwas-good/$i-linear \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-unrel \
          --keep ../unrelated/rand.100000 \
          --extract ../gen/snps-unrel-inds.use \
          --covar ../phen/covariates.use \
          --max-threads 2 \
"> sh_script/$i-linear.sh
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-linear.sh
done>../job-records/gwas-good

# check job completion----------------------------------------------------------
file=job-records/gwas-good
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# resubmit failed/incomplete jobs-----------------------------------------------

for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --linear ../unrelated/gwas-good/$i-linear-chr-$j \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile ../gen/geno-unrel \
          --keep ../unrelated/rand.100000 \
          --extract ../gen/snps-unrel-inds.use \
          --covar ../phen/covariates.use \
          --max-threads 2 \
          --chr $j
"> sh_script/$i-linear-chr-$j.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for j in {1..22}; do
sbatch -A snpher ../sh_script/$i-linear-chr-$j.sh
done
done>../job-records/gwas-good-resubmission

# check job completion----------------------------------------------------------
file=job-records/gwas-good-resubmission
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# combine results
# only need .summaries & .pvalues
#for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper}; do 
i=quals 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-chr-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-chr-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-chr-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-chr-$j.pvalues >> $i-linear.pvalues
fi
done
#done

```

## ldsc intercept

### under gcta

```{bash eval=F}
#:::::::::::::
# using original ldsc
#:::::::::::::

# format stats for ldsc--------------------------------------------------------- 
library(vroom)
options(scipen = 100)
rs=vroom("doug/ukbb.ldsc", col_names=F)
phen=c("awake","bmi","chron","ever","fvc",
       "height","imp","neur","pulse","quals",
       "reaction","sbp","snoring","hyper", "quals")

for(i in phen){
  stat=vroom(paste0("unrelated/gwas-good/",i,"-linear.summaries"), col_names=T)
  p=vroom(paste0("unrelated/gwas-good/",i,"-linear.pvalues"), col_names=T)
  m1=match(rs$X1, stat$Predictor)
  m2=match(rs$X1, p$Predictor)
  out=data.frame(SNP=rs$X2,
                 N=stat$n[m1],
                 Z=(sqrt(stat$Stat)*stat$Direction)[m1],
                 A1=stat$A1[m1],
                 A2=stat$A2[m1], 
                 pval=p$P[m2], stringsAsFactors=F)
  out=out[complete.cases(out),]
  write.table(out, paste0("unrelated/gwas-good/",i,"-linear-rs.summaries"), 
  col.names=T, row.names=F, quote=F)
}

# perform ldsc------------------------------------------------------------------
mkdir out-good-gwas
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 3
#SBATCH -t 24:00:0

.././munge_sumstats.py \
--sumstats ../../unrelated/gwas-good/$i-linear-rs.summaries \
--out ../out-good-gwas/$i \
--merge-alleles ../w_hm3.snplist

.././ldsc.py \
--h2 ../out-good-gwas/$i.sumstats.gz \
--ref-ld-chr ../eur_w_ld_chr/ \
--w-ld-chr ../eur_w_ld_chr/ \
--out ../out-good-gwas/$i-ldsc
">sh_script/ldsc-$i-good-gwas.sh
done

# submit jobs-------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper,quals}; do
sbatch -A snpher ../sh_script/ldsc-$i-good-gwas.sh
done>../../job-records/ldsc-good-gwas

#:::::::::::::
# using sumher
#:::::::::::::

# insert genetic distance into bim file-----------------------------------------
head geno-unrel.fam > small-unrel

for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 3:00:0
#SBATCH --constraint \"s04|s05\"
./plink1.9 --bfile ../gen/geno-unrel \
          --chr $j \
          --cm-map /home/zhoux/snpher/faststorage/genetic_maps/genetic_map_chr@_combined_b37.txt \
          --make-bed \
          --out new$j \
          --keep ../gen/small-unrel
" > sh_script/map$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/map$j
done > genetic-distance-hapmap3

cd /home/zhoux/dsmwpred/xuan/quality-control/qc-10oct/gen
cat new{1..22}.bim | awk '{print $2, $3}' > maps-hapmap3.txt
rm new{1..22}.{bim,bed,fam,log}

awk '(NR==FNR){arr[$1]=$2;next}{print $1, $2, arr[$2], $4, $5, $6}' > geno-unrel.bim2 maps-hapmap3.txt geno-unrel.bim
mv geno-unrel.bim geno-unrel.bim0
mv geno-unrel.bim2 geno-unrel.bim

# compute tagging under gcta----------------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --calc-tagging ../tagging/gcta-hapmap3-chr-$j \
          --bfile ../gen/geno-unrel \
          --ignore-weights YES \
          --power -1 \
          --window-cm 1 \
          --chr $j
"> sh_script/tagging-gcta-hapmap3-chr$j
done

for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-gcta-hapmap3-chr$j 
done > ../job-records/tagging-gcta-hapmap3

# check job completion----------------------------------------------------------
file=job-records/tagging-gcta-hapmap3
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
for j in {1..22}; do 
echo "tagging/gcta-hapmap3-chr-$j.tagging" >> list.txt
done
./ldak5.1 --join-tagging tagging/gcta-hapmap3 --taglist list.txt

# ldsc intercept----------------------------------------------------------------
mkdir sumher-good
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 5:0:0

./ldak5.1 --sum-hers ../sumher-good/$i-sumher-gcta \
          --tagfile ../tagging/gcta-hapmap3.tagging \
          --summary ../unrelated/gwas-good/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-gcta-unrelated
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-gcta-unrelated
done>../job-records/sumher-gcta-unrelated

```

### under ldak-thin

```{bash eval=F}

# get weights-------------------------------------------------------------------
awk < ldak-thin/ldak-thin-hapmap3.in '{print $1, 1}' > ldak-thin/weights.ldak-thin-hapmap3

# calculate tagging under ldak-thin---------------------------------------------
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 40G
#SBATCH -c 5
#SBATCH -t 10:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --calc-tagging ../tagging/ldak-thin-hapmap3-chr-$j \
          --bfile ../gen/geno-unrel \
          --weights ../ldak-thin/weights.ldak-thin-hapmap3 \
          --power -.25 \
          --window-cm 1 \
          --chr $j \
          --save-matrix YES \
          --max-threads 5
" > sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done

# submit scripts
for j in {1..22}; do
sbatch -A snpher ../sh_script/tagging-ldak-thin-hapmap3-chr$j.sh
done > ../job-records/tagging-ldak-thin-hapmap3

# check job completion----------------------------------------------------------
file=job-records/tagging-ldak-thin-hapmap3
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge tagging files-----------------------------------------------------------
rm list.txt
rm matlist.txt
for j in {1..22}; do 
echo "tagging/ldak-thin-hapmap3-chr-$j.tagging" >> list.txt
echo "tagging/ldak-thin-hapmap3-chr-$j.matrix" >> matlist.txt
done
./ldak5.1 --join-tagging tagging/ldak-thin-hapmap3 --taglist list.txt --matlist matlist.txt

# ldsc intercept----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 5G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --sum-hers ../sumher-good/$i-sumher-ldak-thin \
          --tagfile ../tagging/ldak-thin-hapmap3.tagging \
          --summary ../unrelated/gwas-good/$i-linear.summaries \
          --check-sums NO \
          --intercept YES
"> sh_script/$i-sumher-ldak-thin-unrelated
done

for i in {awake,bmi,chron,ever,fvc,height,quals,imp,neur,pulse,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-sumher-ldak-thin-unrelated
done>../job-records/sumher-ldak-thin-unrelated

```

### summary

```{bash eval=F}

# original ldsc
grep Intercept *ldsc.log | awk '{split($1, a, /[-]/); split($3, b, /[()]/); print a[1], $2, b[2]}' > ../../summary/ldsc-good

# sumher under gcta
grep Intercept_Estimate *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-good-est
grep Intercept_SD *gcta.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-gcta-good-sd
cd ../summary/
paste sumher-gcta-good-est sumher-gcta-good-sd | awk '{print $1, $2, $4}' > sumber-gcta-good
      
# submer under ldak-thin
grep Intercept_Estimate *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-good-est
grep Intercept_SD *ldak-thin.extra | awk '{ split($1, a, /[-]/); print a[1], $2}' >../summary/sumher-ldak-thin-good-sd
cd ../summary/
paste sumher-ldak-thin-good-est sumher-ldak-thin-good-sd | awk '{print $1, $2, $4}' > sumher-ldak-thin-good

```

## REML

### making grms
```{bash eval=F}

# making grm -------------------------------------------------------------------

#:::
# under gcta
#:::

# all snps
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 60G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-all-unrel \
          --bfile ../gen/geno-unrel \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-all-snps-unrel

sbatch -A snpher ../sh_script/grm-all-snps-unrel > ../job-records/grm-all-snps-unrel

# grm by snp blocks: right vs. left
awk '$1<8 {print $2}' geno-unrel.bim > left-hapmap3.snps 
awk '$1>=8 {print $2}' geno-unrel.bim > right-hapmap3.snps

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 60G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/gcta-$i-unrel \
          --bfile ../gen/geno-unrel \
          --extract ../gen/$i-hapmap3.snps \
          --power -1 \
          --ignore-weights YES \
          --single YES
" > sh_script/grm-gcta-$i-unrel
done

for i in left right; do
sbatch -A snpher ../sh_script/grm-gcta-$i-unrel 
done > ../job-records/grm-gcta-by-snps-unrel 

#:::
# under ldak-thin
#:::

#-----------
# 1. thin snps
#-----------

for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 4
#SBATCH -t 4:0:0
#SBATCH --constraint \"s04|s05\"
./ldak5.1 --max-threads 4 \
          --window-prune 0.98 \
          --window-kb 100 \
          --extract ../gen/snps-unrel-inds.use \
          --bfile ../gen/geno-unrel \
          --thin ../ldak-thin/chr$j-hapmap3 \
          --chr $j
" > sh_script/ldak-thin$j-hapmap3
done

# submit script
for j in {1..22}; do
sbatch -A snpher ../sh_script/ldak-thin$j-hapmap3
done > ../job-records/ldak-thin-hapmap3

# check job completion---
file=job-records/ldak-thin-hapmap3
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# combine snp list
cat ldak-thin/chr{1..22}-hapmap3.in > ldak-thin/ldak-thin-hapmap3.in

#----------------------
# 2. kinship matrix under ldak-thin
#------------------------

echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 60G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-all-unrel \
          --bfile ../gen/geno-unrel \
          --extract ../ldak-thin/ldak-thin-hapmap3.in \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-all-snps-unrel

sbatch -A snpher ../sh_script/ldak-thin-grm-all-snps-unrel > ../job-records/ldak-thin-grm-all-snps-unrel

# grm by snp blocks: right vs. left

awk '{split($1, a, /[:]/); if (a[1]<8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/left-ldak-thin-hapmap3.snps 
awk '{split($1, a, /[:]/); if (a[1]>=8) print $1}' \
 ldak-thin/ldak-thin-hapmap3.in > gen/right-ldak-thin-hapmap3.snps 

for i in left right; do
echo "#"'!'"/bin/bash
#SBATCH --partition normal
#SBATCH --mem 60G
#SBATCH -c 10
#SBATCH -t 20:0:0
#SBATCH --constraint \"s04|s05\"

./ldak5.1 --max-threads 10 \
          --calc-kins-direct ../kinship/ldak-thin-$i-unrel \
          --bfile ../gen/geno-unrel \
          --extract ../gen/$i-ldak-thin-hapmap3.snps \
          --power -0.25 \
          --ignore-weights YES \
          --single YES
" > sh_script/ldak-thin-grm-$i-unrel
done

for i in left right; do
sbatch -A snpher ../sh_script/ldak-thin-grm-$i-unrel 
done > ../job-records/grm-ldak-thin-by-snps-unrel 

```

### fast-reml
```{bash eval=F}

#:::
# under gcta
#:::

# make script files-------------------------------------------------------------
mkdir reml-good
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-good/$i-gcta-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --keep ../unrelated/rand.100000 \
          --covar ../phen/covariates.use \
          --grm ../kinship/gcta-$k-unrel \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-good-gcta-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-good-gcta-$k-snps
done
done>../job-records/reml-good-gcta

# check job completion----------------------------------------------------------
file=job-records/reml-good-gcta
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::
# under ldak-thin
#:::

# make script files-------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 100G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --fast-reml ../reml-good/$i-ldak-thin-$k \
          --repetitions 20 \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --keep ../unrelated/rand.100000 \
          --covar ../phen/covariates.use \
          --grm ../kinship/ldak-thin-$k-unrel \
          --max-threads 2 \
          --single YES
"> sh_script/$i-reml-good-ldak-thin-$k-snps
done
done

# submit script files-----------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-reml-good-ldak-thin-$k-snps
done
done >../job-records/reml-good-ldak-thin

# check job completion----------------------------------------------------------
file=job-records/reml-good-ldak-thin
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### inflation test

```{bash eval=F}
#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-gcta-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-good.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-gcta-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-good.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-gcta-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-gcta-good.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/reml-gcta-good.all"), header=T)
left=read.table(paste0("summary/reml-gcta-good.left"), header=T)
right=read.table(paste0("summary/reml-gcta-good.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/reml-gcta-inflation-good-gwas.txt"),
            col.names=T, row.names=F, quote=F)

#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-ldak-thin-right.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-good.right
rm summary/est.tmp summary/converge.tmp

# left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-ldak-thin-left.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-good.left
rm summary/est.tmp summary/converge.tmp

# all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=reml-good/$i-ldak-thin-all.reml
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/est.tmp
awk '$1=="Converged" {print$2}' $outfile >> summary/converge.tmp
done
paste  summary/est.tmp \
       summary/converge.tmp \
       | awk 'BEGIN{print "code h2 se converge"}{print i, $0}' \
       > summary/reml-ldak-thin-good.all
rm summary/est.tmp summary/converge.tmp

# inflation test----------------------------------------------------------------
R
full=read.table(paste0("summary/reml-ldak-thin-good.all"), header=T)
left=read.table(paste0("summary/reml-ldak-thin-good.left"), header=T)
right=read.table(paste0("summary/reml-ldak-thin-good.right"), header=T)
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}

write.table(out, paste0("summary/reml-ldak-thin-inflation.txt"),
            col.names=T, row.names=F, quote=F)

```

## HE

### estimation
```{bash eval=F}
# regress grm on covariates-----------------------------------------------------
for grm in gcta-all-unrel gcta-left-unrel gcta-right-unrel ldak-thin-all-unrel ldak-thin-left-unrel ldak-thin-right-unrel; do  
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 50G
#SBATCH -c 5
#SBATCH -t 10:0:0
./ldak5.1 --adjust-grm ../kinship/$grm.covar \
          --grm ../kinship/$grm \
          --covar ../phen/covariates.use \
          --max-threads 5
"> sh_script/$grm-adjust-unrel.sh
done

# submit jobs
for grm in gcta-all-unrel gcta-left-unrel gcta-right-unrel ldak-thin-all-unrel ldak-thin-left-unrel ldak-thin-right-unrel; do
sbatch -A snpher ../sh_script/$grm-adjust-unrel.sh
done > ../job-records/grm-unrel-adjust-for-HE

# check job completion----------------------------------------------------------
file=job-records/grm-unrel-adjust-for-HE
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# HE under gcta-----------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 00:30:0

./ldak5.1 --he ../he-good/$i-he-gcta-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/gcta-$k-unrel.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-good-gcta-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-good-gcta-$k-snps.sh
done
done > ../job-records/he-good-gcta

# HE under ldak-thin------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 2G
#SBATCH -c 1
#SBATCH -t 0:30:0

./ldak5.1 --he ../he-good/$i-he-ldak-thin-$k \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --grm ../kinship/ldak-thin-$k-unrel.covar \
          --kinship-details NO \
          --check-root NO \
          --covar ../phen/covariates.use \
          --max-threads 1 \
          --memory-save YES
"> sh_script/$i-he-good-ldak-thin-$k-snps.sh
done
done

# submit files------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for k in all left right; do
sbatch -A snpher ../sh_script/$i-he-good-ldak-thin-$k-snps.sh
done
done > ../job-records/he-good-ldak-thin

```

### summary

```{bash eval=F}

#::::::::::::
# under gcta
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-gcta-unrel.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-gcta-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-unrel.right
done

# left
rm summary/he-gcta-unrel.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-gcta-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-unrel.left
done

# all
rm summary/he-gcta-unrel.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-gcta-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-gcta-unrel.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-gcta-unrel.all"), header=F)
left=read.table(paste0("summary/he-gcta-unrel.left"), header=F)
right=read.table(paste0("summary/he-gcta-unrel.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-gcta-inflation-unrel-gwas.txt"),
            col.names=T, row.names=F, quote=F)

#::::::::::::
# under ldak-thin
#::::::::::::

# extract h2 estimates ---------------------------------------------------------
# right
rm summary/he-ldak-thin-unrel.right 
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-ldak-thin-right.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-unrel.right
done

# left
rm summary/he-ldak-thin-unrel.left
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-ldak-thin-left.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-unrel.left
done

# all
rm summary/he-ldak-thin-unrel.all
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
outfile=he-good/$i-he-ldak-thin-all.he
awk -v i=$i '$1=="Her_All" {print i, $2, $3}' $outfile >> summary/he-ldak-thin-unrel.all
done

# inflation test----------------------------------------------------------------
R

full=read.table(paste0("summary/he-ldak-thin-unrel.all"), header=F)
left=read.table(paste0("summary/he-ldak-thin-unrel.left"), header=F)
right=read.table(paste0("summary/he-ldak-thin-unrel.right"), header=F)
names(full)=names(left)=names(right)=c("code","h2","se")
# some analyses did not complete --> match dataframes
dim(full);dim(left);dim(right)
common=intersect(full$code, left$code)
common=intersect(common, right$code)
m1=match(common, right$code)
m2=match(common, full$code)
m3=match(common, left$code)
right=right[m1,]
full=full[m2,]
left=left[m3,]

for(i in 1:dim(full)[1]){
    
    est1=left$h2[i]
    sd1=left$se[i]
    est2=right$h2[i]
    sd2=right$se[i]
    est=full$h2[i]
    sd=full$se[i]
    N=100000
    d1=rnorm(N,est1,sd1)
    d2=rnorm(N,est2,sd2)
    d=rnorm(N,est,sd)
    p=1-mean(d1+d2-d>=0)
    
    out0=data.frame(code=full$code[i],
                    right_est=est2,
                    right_sd=sd2,
                    left_est=est1,
                    left_sd=sd1,
                    all_est=est,
                    all_sd=sd,
                    p_inflation=p)
   if(i==1){out=out0}else{out=rbind(out,out0)}
}
write.table(out, paste0("summary/he-ldak-thin-inflation-unrel-gwas.txt"),
            col.names=T, row.names=F, quote=F)

```

