
# related individuals

## $\overline{r^2_j}$ & relatedness

Previously we performed analyses on icd10 traits using related individuals. Here are relevant files:

  * **bfile**: gen/geno-rel: created using icd10/related.inds
  * **id lists**:
    * 56757 icd10/related.inds
    * 56754 relatedness/cut.05.related: relatedness >= 0.05.
    * 56753 relatedness/cut.125.related
    * 48197 relatedness/cut.25.related
    * 18294 relatedness/cut.5.related
  * **snp list** after QC: gen/snps-rel-inds.use : 627,320 SNPs 


```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# create id lists & snp lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# unrelated ids----------------------------------------------------------------
# serve as control groups
n=(56753 48197 18294)
nm=(cut.125 cut.25 cut.5)

for i in {0..2}; do
shuf rand.100000 | head -n ${n[$i]} > white-unrel-rand-control-for-${nm[$i]}
done

# snp list----------------------------------------------------------------------
# common snps of related & unrelated
unrel=gen/snps-unrel-inds.use # 1,103,209
rel=gen/snps-rel-inds.use # 627,320 SNPs
awk 'NR==FNR{a[$1];next} 
    ($1 in a) {print $1}' $unrel $rel > gen/common-unrel-rel-snps # 153,313

# lista & listb
# this will be common for all id lists
m=10000
infile=gen/common-unrel-rel-snps
left=inflation/related/left-snps
right=inflation/related/right-snps

awk '{split($1, a, ":");
    if (a[1]<8) print $1 }' $infile | shuf | head -n $m >$left  
awk '{split($1, a, ":");
    if (a[1]>=8) print $1 }' $infile | shuf | head -n $m >$right

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

for nm in {cut.125,cut.25,cut.5}; do

# common snp lists
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps

# related individuals
id=../relatedness/$nm.related
bfile=../gen/geno-rel
out=../inflation/related/out/10k-snps-$nm-rel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-rel

# unrelated controls
id=../white-unrel-rand-control-for-$nm
bfile=../gen/geno-unrel
out=../inflation/related/out/10k-snps-$nm-unrel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-unrel
done

# submit the job
for nm in {cut.125,cut.25,cut.5}; do
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-rel
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-unrel
done>../job-records/calc-r-related

#  compute ave r_j^2 for each i-------------------------------------------------
R
require(vroom)
cut=c("cut.125","cut.25","cut.5")
rel=c("rel","unrel")

for(j in 1:length(rel)){
for(i in 1:length(cut)){
    nm=paste0("10k-snps-",cut[i],"-",rel[j])
    dat=vroom(paste0("inflation/related/out/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0("inflation/related/out/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0("inflation/related/out/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(10001)]^2
    outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
    outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    out=rbind(outa,outb)
    
    write.table(out,paste0("summary/ave-r2-",nm), col.names=F, row.names=F, quote=F)  
  }
}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# summary
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# check if mean r^2_j differs for rel vs. unrel

cut=c("cut.125","cut.25","cut.5")

for(i in 1:length(cut)){
    nm_rel=paste0("ave-r2-10k-snps-",cut[i],"-rel")
    nm_unrel=paste0("ave-r2-10k-snps-",cut[i],"-unrel")
    
    dat_rel=read.table(paste0("summary/",nm_rel),stringsAsFactors = F)
    dat_unrel=read.table(paste0("summary/",nm_unrel),stringsAsFactors = F)
    
    out0=data.frame(rel=cut[i],
                    rel_ave=mean(dat_rel$V2),
                    rel_sd=sd(dat_rel$V2),
                    unrel_ave=mean(dat_unrel$V2),
                    unrel_sd=sd(dat_unrel$V2),
                    stringsAsFactors = F)
      if(i==1){out1=out0}else{out1=rbind(out1,out0)}
  }


```

## GWAS

```{bash eval=F}

# create directories------------------------------------------------------------
for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do
mkdir gwas-$j-$i
done
done

# gwas -------------------------------------------------------------------------
for j in {cut.125,cut.25,cut.5}; do
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

# related individuals----------------------
out=../gwas-$j-rel/$i-linear
id=../relatedness/$j.related
snp=../gen/snps-rel-inds.use
bfile=../gen/geno-rel
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/covariates.use \
          --max-threads 2 \
"> sh_script/$i-linear-$j-rel.sh

# unrelated individuals----------------------
out=../gwas-$j-unrel/$i-linear
id=../white-unrel-rand-control-for-$j
snp=../gen/snps-unrel-inds.use
bfile=../gen/geno-unrel
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/covariates.use \
          --max-threads 2 \
"> sh_script/$i-linear-$j-unrel.sh
done
done

# submit jobs
for j in {cut.125,cut.25,cut.5}; do
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-linear-$j-rel.sh
sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh
done
done>../job-records/gwas-related

# check job completion
file=job-records/gwas-related
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

## organize data

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# compute MAF
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do

out=../gen/maf/geno-$j-$i

if [ $i == rel ]; then
  bfile=../gen/geno-rel
  id=../relatedness/$j.related
else
  bfile=../gen/geno-unrel
  id=../white-unrel-rand-control-for-$j
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --calc-stats $out \
          --bfile $bfile \
          --keep $id
    
"> sh_script/calc-maf-$j-$i.sh
done
done

# submit script
for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do
sbatch -A snpher ../sh_script/calc-maf-$j-$i.sh
done
done>../job-records/calc-maf-rel

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# extract LD scores
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# we do this for related individuals.
# ld scores of snp list for unrelated id: snps-unrel-maf.001.ldscore 

# convert snp list to rs system ------------------------------------------------
infile=gen/snps-rel-inds.use
outfile=gen/snps-rel-rs
awk '(NR==FNR){a[$1]; b[$1]=$2; next}
     ($1 in a){print b[$1], $2}' doug/ukbb.ldsc $infile > $outfile

#  extract ld scores -----------------------------------------------------------
dir=ldsc/eur_w_ld_chr
for chrom in {1..22}; do
zcat $dir/$chrom.l2.ldscore.gz | awk 'NR>1 {print $2, $6}' > ldscore
awk '(NR==FNR){a[$1];next}($1 in a){print $0}' gen/snps-rel-rs ldscore > temp
if [ $chrom -eq 1 ]
then 
 mv temp snps-rel.ldscore
else
 cat snps-rel.ldscore temp > temp2
 mv temp2 snps-rel.ldscore
fi
echo $chrom
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  put info together
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# maf: gen/maf/geno-[cut.125]-[rel]
# chi square : gwas-[cut.125]-[rel]/[trait]-linear.summaries
# ave r^2_j: summary/ave-r2-10k-snps-[cut.25]-[unrel]
# ld score from ldsc ref panel: snps-unrel-maf.001.ldscore; snps-rel.ldscore

# fixed file
rs=doug/ukbb.ldsc

for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do

# files vary depending on j &/or  i
maf=gen/maf/geno-$j-$i.stats # use as the snp list to integrate all info
aver2=summary/ave-r2-10k-snps-$j-$i

if [ $i == rel ]; then
  ldsc=snps-rel.ldscore
else
  ldsc=snps-unrel-maf.001.ldscore
fi

# create temporary files
awk 'NR > 1 {print $1, $5 }' $maf > tmp/maf.tmp
awk 'NR==FNR {a[$2]; b[$2]=$1; next} ($1 in a) {print b[$1], $0}' $rs $ldsc > tmp/ldsc.tmp1
# here we make sure the order of the rows are the same as maf.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; c[$1]=$3 ; next} 
     {if ($1 in a) print b[$1], c[$1];
      else print "NA"}' tmp/ldsc.tmp1 tmp/maf.tmp > tmp/ldsc.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/maf.tmp > tmp/aver2.tmp

for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

# files vary with j, i and trait
gwas=gwas-$j-$i/$trait-linear.summaries
out=gwas-related-all-out/$trait-$j-$i.out

awk 'NR==FNR {a[$1]; b[$1]=$5; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $gwas tmp/maf.tmp > tmp/gwas.tmp     

# put info together
paste tmp/maf.tmp \
      tmp/gwas.tmp \
      tmp/aver2.tmp \
      tmp/ldsc.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;maf;chisq;aver2;rs;ldsc"}
             {$1=$1}1' > $out
done
done
done

```

## summary

```{R eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

#cuts=c("cut.125","cut.25","cut.5")
cuts="cut.125"
related=c("rel","unrel")

traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(related)){
  for(j in 1:length(cuts)){
    for(k in 1:length(traits)){

    rel=related[i]
    cut=cuts[j]
    trait=traits[k]
    
    file=paste0("gwas-related-all-out/",trait,"-",cut,
                    "-",rel,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod=lm(chisq ~ aver2,data=dat)
  
    slope0=data.frame(trait=trait,
                      cutoff=cut,
                      rel=rel,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1 & j==1 & k==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
    }
  }
}

out=slope[order(slope$trait, slope$cutoff, slope$rel),]
#write.table(out,"summary/chisq-aver2-slope-gwas-related.txt", 
#            col.names=T, row.names=F, quote=F)


#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  by rel | cut
#::::::::::::::::::::::::::::::::::::::::::::::

# function to plot a single trait---------------------------------------------------

make_plot=function(trait, cut){
  
  # define variables
  cut=cut
  trait=trait
  
  # define color
  library(RColorBrewer)
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  set.seed(14)
  mycol=sample(col_vector,2)
  
  # related 
    file1=paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out")
    dat1=vroom(file1, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat1$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat1$bin=cut(dat1$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out1=data.frame(chisq_ave=tapply(dat1$chisq,INDEX=dat1$bin, mean))
    out1$bin_val=tapply(dat1$aver2,INDEX=dat1$bin, mean)
  
   # unrelated 
    file2=paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out")
    dat2=vroom(file2, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat2$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat2$bin=cut(dat2$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out2=data.frame(chisq_ave=tapply(dat2$chisq,INDEX=dat2$bin, mean))
    out2$bin_val=tapply(dat2$aver2,INDEX=dat2$bin, mean)  
    
    xstart=min(out1$bin_val,out2$bin_val)
    xend=max(out1$bin_val,out2$bin_val)
    ystart=min(out1$chisq_ave,out2$chisq_ave)
    yend=max(out1$chisq_ave,out2$chisq_ave)
    
    plot(out1$bin_val, out1$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         xlim=c(xstart,xend), ylim=c(ystart,yend),
         main=paste0(trait," ", cut), las=1,
         cex = 1.5, pch=21,  bg=mycol[1], col="white", lwd=0.5)
      points(out2$bin_val, out2$chisq_ave,
           cex = 1.5, pch=21, col="white", bg=mycol[2], lwd=0.5)
   if(trait=="awake"){
     legend("topleft", pch=19, legend=c("rel","unrel"), 
            col=mycol, cex=1.5, box.lty=0)}
   
} # end of function

# make a plot ------------------------------------------------------------------

require(vroom)
cuts=c("cut.125","cut.25","cut.5")
related=c("rel","unrel")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:length(cuts)){
  
  cut=cuts[j]
  # plot chisq ~ aver2 by rel for a given cutoff for relatedness
  png(paste0("fig/chisq-by-aver2-bin-related-gwas-",cut,".png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
      for(i in 1:length(traits)){
        trait=traits[i]
        make_plot(trait, cut)
      }
  dev.off()
}

```

## Hapmap3 genotype data 

```{bash eval=F}

#:::
# make bfiles by chromosome
#::::
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../icd10/related.inds \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j \
         --threads 3 \
"> sh_script/chr$j.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i.sh
done>../job-records/mkbfile-related

# check job completion
file=job-records/mkbfile-related
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::
# merge bfiles 
#::::

rm bfile.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j" >>bfile.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 40:0:0
./ldak5.1 --make-bed ../gen/geno-rel-hmp3 \
          --mbfile ../gen/bfile.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/mbfile.sh

# submit the script
sbatch -A snpher ../sh_script/mbfile.sh >../job-records/mbfiles-related

# snp list --------------------------------------------------------------------

# MAF & call-rate 
awk < gen/geno-rel-hmp3.stats '($5>.01 && $6>=0.95 && NR>1)
                              {print $1}' > gen/snps-rel-hmp3.use
# m = 2,284,197 SNPs

# gwas -------------------------------------------------------------------------

#for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
#for j in {cut.125,cut.25,cut.5}; do
i=height
j=cut.125

for chr in {1..22}; do
id=../relatedness/$j.related
snp=../gen/snps-rel-hmp3.use
bfile=../gen/geno-rel-hmp3
out=../gwas-$j-rel/$i-linear-$chr
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/covariates.use \
          --max-threads 2 \
          --chr $chr
"> sh_script/$i-linear-$j-rel-chr-$chr.sh
done
#done
#done

# submit jobs
i=height
j=cut.125
for chr in {1..22}; do
#for j in {cut.125,cut.25,cut.5}; do
#for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-linear-$j-rel-chr-$chr.sh
#sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh
#done
done>../job-records/gwas-related


```

## mix unrel & rel

```{bash eval=F}

#:::
# make bfiles by chromosome
#::::
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../rel-unrel-combo.id \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-combo \
         --threads 3 \
"> sh_script/chr$j.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i.sh
done>../job-records/mkbfile-related-unrel-combo

# check job completion
file=job-records/mkbfile-related-unrel-combo
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::
# merge bfiles 
#::::

rm bfile.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-combo" >>bfile.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 40:0:0
./ldak5.1 --make-bed ../gen/geno-rel-unrel-combo \
          --mbfile ../gen/bfile.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/mbfile.sh

# submit the script

# id list----------------------------------------------------------------
# non-overlapping list
awk 'NR==FNR {a[$1]; next} !($1 in a) {print }' icd10/related.inds unrelated/rand.100000 > tmp.txt
sbatch -A snpher ../sh_script/mbfile.sh >../job-records/mbfiles-rel-unrel-combo
rm tmp

```

