
# related individuals

## genotyped SNPs

### aver2_j

Previously we performed analyses on icd10 traits using related individuals. Here are relevant files:

  * **bfile**: gen/geno-rel: created using icd10/related.inds
  * **id lists**:
    * 56757 icd10/related.inds
    * 56754 relatedness/cut.05.related: relatedness >= 0.05.
    * 56753 relatedness/cut.125.related
    * 48197 relatedness/cut.25.related
    * 18294 relatedness/cut.5.related
  * **snp list** after QC: gen/snps-rel-inds.use : 627,320 SNPs 


```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# create id lists & snp lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# unrelated ids----------------------------------------------------------------
# serve as control groups
n=(56753 48197 18294)
nm=(cut.125 cut.25 cut.5)

for i in {0..2}; do
shuf rand.100000 | head -n ${n[$i]} > white-unrel-rand-control-for-${nm[$i]}
done

# snp list----------------------------------------------------------------------
# common snps of related & unrelated
unrel=gen/snps-unrel-inds.use # 1,103,209
rel=gen/snps-rel-inds.use # 627,320 SNPs
awk 'NR==FNR{a[$1];next} 
    ($1 in a) {print $1}' $unrel $rel > gen/common-unrel-rel-snps # 153,313

# lista & listb
# this will be common for all id lists
m=10000
infile=gen/common-unrel-rel-snps
left=inflation/related/left-snps
right=inflation/related/right-snps

awk '{split($1, a, ":");
    if (a[1]<8) print $1 }' $infile | shuf | head -n $m >$left  
awk '{split($1, a, ":");
    if (a[1]>=8) print $1 }' $infile | shuf | head -n $m >$right

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

for nm in {cut.125,cut.25,cut.5}; do

# common snp lists
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps

# related individuals
id=../relatedness/$nm.related
bfile=../gen/geno-rel
out=../inflation/related/out/10k-snps-$nm-rel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-rel

# unrelated controls
id=../white-unrel-rand-control-for-$nm
bfile=../gen/geno-unrel
out=../inflation/related/out/10k-snps-$nm-unrel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-unrel
done

# submit the job
for nm in {cut.125,cut.25,cut.5}; do
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-rel
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-unrel
done>../job-records/calc-r-related

#  compute ave r_j^2 for each i-------------------------------------------------
R
require(vroom)
cut=c("cut.125","cut.25","cut.5")
rel=c("rel","unrel")

for(j in 1:length(rel)){
for(i in 1:length(cut)){
    nm=paste0("10k-snps-",cut[i],"-",rel[j])
    dat=vroom(paste0("inflation/related/out/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0("inflation/related/out/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0("inflation/related/out/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(10001)]^2
    outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
    outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    out=rbind(outa,outb)
    
    write.table(out,paste0("summary/ave-r2-",nm), col.names=F, row.names=F, quote=F)  
  }
}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# summary
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# check if mean r^2_j differs for rel vs. unrel

cut=c("cut.125","cut.25","cut.5")

for(i in 1:length(cut)){
    nm_rel=paste0("ave-r2-10k-snps-",cut[i],"-rel")
    nm_unrel=paste0("ave-r2-10k-snps-",cut[i],"-unrel")
    
    dat_rel=read.table(paste0("summary/",nm_rel),stringsAsFactors = F)
    dat_unrel=read.table(paste0("summary/",nm_unrel),stringsAsFactors = F)
    
    out0=data.frame(rel=cut[i],
                    rel_ave=mean(dat_rel$V2),
                    rel_sd=sd(dat_rel$V2),
                    unrel_ave=mean(dat_unrel$V2),
                    unrel_sd=sd(dat_unrel$V2),
                    stringsAsFactors = F)
      if(i==1){out1=out0}else{out1=rbind(out1,out0)}
  }


```

### gwas

```{bash eval=F}

# create directories------------------------------------------------------------
for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do
mkdir gwas-$j-$i
done
done

# gwas -------------------------------------------------------------------------
for j in {cut.125,cut.25,cut.5}; do
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

# related individuals----------------------
out=../gwas-$j-rel/$i-linear
id=../relatedness/$j.related
snp=../gen/snps-rel-inds.use
bfile=../gen/geno-rel
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/covariates.use \
          --max-threads 2 \
"> sh_script/$i-linear-$j-rel.sh

# unrelated individuals----------------------
out=../gwas-$j-unrel/$i-linear
id=../white-unrel-rand-control-for-$j
snp=../gen/snps-unrel-inds.use
bfile=../gen/geno-unrel
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/covariates.use \
          --max-threads 2 \
"> sh_script/$i-linear-$j-unrel.sh
done
done

# submit jobs
for j in {cut.125,cut.25,cut.5}; do
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
sbatch -A snpher ../sh_script/$i-linear-$j-rel.sh
sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh
done
done>../job-records/gwas-related

# check job completion
file=job-records/gwas-related
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

```

### organize data

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# compute MAF
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do

out=../gen/maf/geno-$j-$i

if [ $i == rel ]; then
  bfile=../gen/geno-rel
  id=../relatedness/$j.related
else
  bfile=../gen/geno-unrel
  id=../white-unrel-rand-control-for-$j
fi

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 10G
#SBATCH -c 2
#SBATCH -t 5:0:0

./ldak5.1 --calc-stats $out \
          --bfile $bfile \
          --keep $id
    
"> sh_script/calc-maf-$j-$i.sh
done
done

# submit script
for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do
sbatch -A snpher ../sh_script/calc-maf-$j-$i.sh
done
done>../job-records/calc-maf-rel

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# extract LD scores
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# we do this for related individuals.
# ld scores of snp list for unrelated id: snps-unrel-maf.001.ldscore 

# convert snp list to rs system ------------------------------------------------
infile=gen/snps-rel-inds.use
outfile=gen/snps-rel-rs
awk '(NR==FNR){a[$1]; b[$1]=$2; next}
     ($1 in a){print b[$1], $2}' doug/ukbb.ldsc $infile > $outfile

#  extract ld scores -----------------------------------------------------------
dir=ldsc/eur_w_ld_chr
for chrom in {1..22}; do
zcat $dir/$chrom.l2.ldscore.gz | awk 'NR>1 {print $2, $6}' > ldscore
awk '(NR==FNR){a[$1];next}($1 in a){print $0}' gen/snps-rel-rs ldscore > temp
if [ $chrom -eq 1 ]
then 
 mv temp snps-rel.ldscore
else
 cat snps-rel.ldscore temp > temp2
 mv temp2 snps-rel.ldscore
fi
echo $chrom
done

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  put info together
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# maf: gen/maf/geno-[cut.125]-[rel]
# chi square : gwas-[cut.125]-[rel]/[trait]-linear.summaries
# ave r^2_j: summary/ave-r2-10k-snps-[cut.25]-[unrel]
# ld score from ldsc ref panel: snps-unrel-maf.001.ldscore; snps-rel.ldscore

# fixed file
rs=doug/ukbb.ldsc

for j in {cut.125,cut.25,cut.5}; do
for i in {rel,unrel};do

# files vary depending on j &/or  i
maf=gen/maf/geno-$j-$i.stats # use as the snp list to integrate all info
aver2=summary/ave-r2-10k-snps-$j-$i

if [ $i == rel ]; then
  ldsc=snps-rel.ldscore
else
  ldsc=snps-unrel-maf.001.ldscore
fi

# create temporary files
awk 'NR > 1 {print $1, $5 }' $maf > tmp/maf.tmp
awk 'NR==FNR {a[$2]; b[$2]=$1; next} ($1 in a) {print b[$1], $0}' $rs $ldsc > tmp/ldsc.tmp1
# here we make sure the order of the rows are the same as maf.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; c[$1]=$3 ; next} 
     {if ($1 in a) print b[$1], c[$1];
      else print "NA"}' tmp/ldsc.tmp1 tmp/maf.tmp > tmp/ldsc.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/maf.tmp > tmp/aver2.tmp

for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

# files vary with j, i and trait
gwas=gwas-$j-$i/$trait-linear.summaries
out=gwas-related-all-out/$trait-$j-$i.out

awk 'NR==FNR {a[$1]; b[$1]=$5; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $gwas tmp/maf.tmp > tmp/gwas.tmp     

# put info together
paste tmp/maf.tmp \
      tmp/gwas.tmp \
      tmp/aver2.tmp \
      tmp/ldsc.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;maf;chisq;aver2;rs;ldsc"}
             {$1=$1}1' > $out
done
done
done

```

### summary

```{R eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

#cuts=c("cut.125","cut.25","cut.5")
cuts="cut.125"
related=c("rel","unrel")

traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(related)){
  for(j in 1:length(cuts)){
    for(k in 1:length(traits)){

    rel=related[i]
    cut=cuts[j]
    trait=traits[k]
    
    file=paste0("gwas-related-all-out/",trait,"-",cut,
                    "-",rel,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod=lm(chisq ~ aver2,data=dat)
  
    slope0=data.frame(trait=trait,
                      cutoff=cut,
                      rel=rel,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1 & j==1 & k==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
    }
  }
}

out=slope[order(slope$trait, slope$cutoff, slope$rel),]
#write.table(out,"summary/chisq-aver2-slope-gwas-related.txt", 
#            col.names=T, row.names=F, quote=F)


#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  by rel | cut
#::::::::::::::::::::::::::::::::::::::::::::::

# function to plot a single trait---------------------------------------------------

make_plot=function(trait, cut){
  
  # define variables
  cut=cut
  trait=trait
  
  # define color
  library(RColorBrewer)
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  set.seed(14)
  mycol=sample(col_vector,2)
  
  # related 
    file1=paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out")
    dat1=vroom(file1, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat1$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat1$bin=cut(dat1$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out1=data.frame(chisq_ave=tapply(dat1$chisq,INDEX=dat1$bin, mean))
    out1$bin_val=tapply(dat1$aver2,INDEX=dat1$bin, mean)
  
   # unrelated 
    file2=paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out")
    dat2=vroom(file2, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat2$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat2$bin=cut(dat2$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out2=data.frame(chisq_ave=tapply(dat2$chisq,INDEX=dat2$bin, mean))
    out2$bin_val=tapply(dat2$aver2,INDEX=dat2$bin, mean)  
    
    xstart=min(out1$bin_val,out2$bin_val)
    xend=max(out1$bin_val,out2$bin_val)
    ystart=min(out1$chisq_ave,out2$chisq_ave)
    yend=max(out1$chisq_ave,out2$chisq_ave)
    
    plot(out1$bin_val, out1$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         xlim=c(xstart,xend), ylim=c(ystart,yend),
         main=paste0(trait," ", cut), las=1,
         cex = 1.5, pch=21,  bg=mycol[1], col="white", lwd=0.5)
      points(out2$bin_val, out2$chisq_ave,
           cex = 1.5, pch=21, col="white", bg=mycol[2], lwd=0.5)
   if(trait=="awake"){
     legend("topleft", pch=19, legend=c("rel","unrel"), 
            col=mycol, cex=1.5, box.lty=0)}
   
} # end of function

# make a plot ------------------------------------------------------------------

require(vroom)
cuts=c("cut.125","cut.25","cut.5")
related=c("rel","unrel")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:length(cuts)){
  
  cut=cuts[j]
  # plot chisq ~ aver2 by rel for a given cutoff for relatedness
  png(paste0("fig/chisq-by-aver2-bin-related-gwas-",cut,".png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
      for(i in 1:length(traits)){
        trait=traits[i]
        make_plot(trait, cut)
      }
  dev.off()
}

```

## hapmap3 SNPs

### genotype data

```{bash eval=F}

#:::
# make bfiles by chromosome
#::::
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../icd10/related.inds \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j \
         --threads 3 \
"> sh_script/chr$j.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i.sh
done>../job-records/mkbfile-related

# check job completion
file=job-records/mkbfile-related
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::
# merge bfiles 
#::::

rm bfile.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j" >>bfile.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 40:0:0
./ldak5.1 --make-bed ../gen/geno-rel-hmp3 \
          --mbfile ../gen/bfile.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/mbfile.sh

# submit the script
sbatch -A snpher ../sh_script/mbfile.sh >../job-records/mbfiles-related

# snp list --------------------------------------------------------------------

# MAF & call-rate 
awk < gen/geno-rel-hmp3.stats '($5>.01 && $6>=0.95 && NR>1){print $1}' > gen/snps-rel-hmp3.use
# m = 1,105,446 SNPs

```

### gwas

```{bash eval=F}
# script ----------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
#for j in {cut.125,cut.25,cut.5}; do
j=cut.125

for chr in {1..22}; do
id=../relatedness/$j.related
snp=../gen/snps-rel-hmp3.use
bfile=../gen/geno-rel-hmp3
out=../gwas-$j-rel/$i-linear-$chr
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --keep $id \
          --extract $snp \
          --covar ../phen/basic-covariates.use \
          --max-threads 2 \
          --chr $chr
"> sh_script/$i-linear-$j-rel-chr-$chr.sh
done
done
#done

# submit jobs-------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
j=cut.125
for chr in {1..22}; do
#for j in {cut.125,cut.25,cut.5}; do
sbatch -A snpher ../sh_script/$i-linear-$j-rel-chr-$chr.sh
#sbatch -A snpher ../sh_script/$i-linear-$j-unrel.sh
done
done>../job-records/gwas-related

# check job completion----------------------------------------------------------
file=job-records/gwas-related
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

# merge files-------------------------------------------------------------------

# only do .summaries & .pvalues
for i in {awake,bmi,quals,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper}; do 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-$j.pvalues >> $i-linear.pvalues
fi
done
done

```

### aver2_j

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  snp lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# snp list----------------------------------------------------------------------
# common snps of related & unrelated
unrel=gen/snps-unrel-inds.use # 1,103,209
rel=gen/snps-rel-hmp3.use # 1,105,446 SNPs
awk 'NR==FNR{a[$1];next} 
    ($1 in a) {print $1}' $unrel $rel > gen/common-unrel-rel-snps # 1,101,844

# lista & listb
# this will be common for all id lists
m=10000
infile=gen/common-unrel-rel-snps
left=inflation/related/left-snps
right=inflation/related/right-snps

awk '{split($1, a, ":");
    if (a[1]<8) print $1 }' $infile | shuf | head -n $m >$left  
awk '{split($1, a, ":");
    if (a[1]>=8) print $1 }' $infile | shuf | head -n $m >$right

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#for nm in {cut.125,cut.25,cut.5}; do
nm=cut.125
# common snp lists
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps

# related individuals
id=../relatedness/$nm.related
bfile=../gen/geno-rel-hmp3
out=../inflation/related/out/10k-snps-$nm-rel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-rel

# unrelated controls
id=../white-unrel-rand-control-for-$nm
bfile=../gen/geno-unrel
out=../inflation/related/out/10k-snps-$nm-unrel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --keep $id \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-$nm-unrel
#done

# submit the job
#for nm in {cut.125,cut.25,cut.5}; do
for nm in cut.125; do
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-rel
sbatch -A snpher ../sh_script/calc-r-10k-snps-$nm-unrel
done>../job-records/calc-r-related

#  compute ave r_j^2 for each i-------------------------------------------------
R
require(vroom)
#cut=c("cut.125","cut.25","cut.5")
cut=c("cut.125")
rel=c("rel","unrel")

for(j in 1:length(rel)){
for(i in 1:length(cut)){
    nm=paste0("10k-snps-",cut[i],"-",rel[j])
    dat=vroom(paste0("inflation/related/out/",nm,".pairwise"), col_names=F)
    lista=read.table(paste0("inflation/related/out/",nm,".predictorsa"), stringsAsFactors = F)
    listb=read.table(paste0("inflation/related/out/",nm,".predictorsb"), stringsAsFactors = F)
    
    dat=dat[,-c(10001)]^2
    outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
    outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
    out=rbind(outa,outb)
    
    write.table(out,paste0("summary/ave-r2-",nm), col.names=F, row.names=F, quote=F)  
  }
}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# summary
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# check if mean r^2_j differs for rel vs. unrel

#cut=c("cut.125","cut.25","cut.5")
cut=c("cut.125")
for(i in 1:length(cut)){
    nm_rel=paste0("ave-r2-10k-snps-",cut[i],"-rel")
    nm_unrel=paste0("ave-r2-10k-snps-",cut[i],"-unrel")
    
    dat_rel=read.table(paste0("summary/",nm_rel),stringsAsFactors = F)
    dat_unrel=read.table(paste0("summary/",nm_unrel),stringsAsFactors = F)
    
    out0=data.frame(rel=cut[i],
                    rel_ave=mean(dat_rel$V2),
                    rel_sd=sd(dat_rel$V2),
                    unrel_ave=mean(dat_unrel$V2),
                    unrel_sd=sd(dat_unrel$V2),
                    stringsAsFactors = F)
      if(i==1){out1=out0}else{out1=rbind(out1,out0)}
  }

```

### organize data

```{bash eval=F}

#for j in {cut.125,cut.25,cut.5}; do
for j in cut.125; do
for i in {rel,unrel};do
for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
gwas=gwas-$j-$i/$trait-linear.summaries
aver2=summary/ave-r2-10k-snps-$j-$i
out=gwas-related-all-out/$trait-$j-$i.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp
awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done
done
done

```

### chisq ~ aver2_j

```{r eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

#cuts=c("cut.125","cut.25","cut.5")
cuts="cut.125"
related=c("rel","unrel")

traits=c("awake","bmi","chron","ever",
       "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(related)){
  for(j in 1:length(cuts)){
    for(k in 1:length(traits)){

    rel=related[i]
    cut=cuts[j]
    trait=traits[k]
    
    file=paste0("gwas-related-all-out/",trait,"-",cut,
                    "-",rel,".out")
    
    dat=vroom(file, col_names=T, delim=";")
    mod=lm(chisq ~ aver2,data=dat)
  
    slope0=data.frame(trait=trait,
                      cutoff=cut,
                      rel=rel,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1 & j==1 & k==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
    }
  }
}

out=slope[order(slope$trait, slope$cutoff, slope$rel),]
#write.table(out,"summary/chisq-aver2-slope-gwas-related.txt", 
#            col.names=T, row.names=F, quote=F)


#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  by rel | cut
#::::::::::::::::::::::::::::::::::::::::::::::

# function to plot a single trait---------------------------------------------------

make_plot=function(trait, cut){
  
  # define variables
  cut=cut
  trait=trait
  
  # define color
  library(RColorBrewer)
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  set.seed(14)
  mycol=sample(col_vector,2)
  
  # related 
    file1=paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out")
    dat1=vroom(file1, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat1$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat1$bin=cut(dat1$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out1=data.frame(chisq_ave=tapply(dat1$chisq,INDEX=dat1$bin, mean))
    out1$bin_val=tapply(dat1$aver2,INDEX=dat1$bin, mean)
  
   # unrelated 
    file2=paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out")
    dat2=vroom(file2, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat2$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat2$bin=cut(dat2$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out2=data.frame(chisq_ave=tapply(dat2$chisq,INDEX=dat2$bin, mean))
    out2$bin_val=tapply(dat2$aver2,INDEX=dat2$bin, mean)  
    
    xstart=min(out1$bin_val,out2$bin_val)
    xend=max(out1$bin_val,out2$bin_val)
    ystart=min(out1$chisq_ave,out2$chisq_ave)
    yend=max(out1$chisq_ave,out2$chisq_ave)
    
    plot(out1$bin_val, out1$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         xlim=c(xstart,xend), ylim=c(ystart,yend),
         main=paste0(trait," ", cut), las=1,
         cex = 1.5, pch=21,  bg=mycol[1], col="white", lwd=0.5)
      points(out2$bin_val, out2$chisq_ave,
           cex = 1.5, pch=21, col="white", bg=mycol[2], lwd=0.5)
   if(trait=="awake"){
     legend("topleft", pch=19, legend=c("rel","unrel"), 
            col=mycol, cex=1.5, box.lty=0)}
   
} # end of function

# make a plot ------------------------------------------------------------------

require(vroom)
#cuts=c("cut.125","cut.25","cut.5")
cuts="cut.125"
related=c("rel","unrel")
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:length(cuts)){
  
  cut=cuts[j]
  # plot chisq ~ aver2 by rel for a given cutoff for relatedness
  png(paste0("fig/chisq-by-aver2-bin-related-gwas-",cut,".png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
      for(i in 1:length(traits)){
        trait=traits[i]
        make_plot(trait, cut)
      }
  dev.off()
}

```

### inflation ~ aver2_j

```{r eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: inflation ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

cuts="cut.125"

traits=c("awake","bmi","chron","ever",
       "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(j in 1:length(cuts)){
    for(k in 1:length(traits)){

    cut=cuts[j]
    trait=traits[k]
    
    f1=paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out")
    f2=paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out")
    
    d1=vroom(f1, col_names=T, delim=";")
    d2=vroom(f2, col_names=T, delim=";")
    common=intersect(d1$snp, d2$snp)
    m1=match(common, d1$snp)
    m2=match(common, d2$snp)
    dat=data.frame(snp=common,
                   inflation=d1$chisq[m1]-d2$chisq[m2],
                   aver2=d1$aver2[m1])
    
    mod=lm(inflation ~ aver2,data=dat)
  
    slope0=data.frame(trait=trait,
                      cutoff=cut,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(j==1 & k==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
    }
}

out=slope[order(slope$trait, slope$cutoff),]
#write.table(out,"summary/chisq-aver2-slope-gwas-related.txt", 
#            col.names=T, row.names=F, quote=F)


#::::::::::::::::::::::::::::::::::::::::::::::
# plot inflation ~ aver2_j  
#::::::::::::::::::::::::::::::::::::::::::::::
# make a plot ------------------------------------------------------------------
require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
cut="cut.125"       
png(paste0("fig/inflation-by-aver2-bin-related-gwas.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
for (i in 1:length(traits)){

    trait=traits[i]
    f1=paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out")
    f2=paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out")
    
    d1=vroom(f1, col_names=T, delim=";")
    d2=vroom(f2, col_names=T, delim=";")
    common=intersect(d1$snp, d2$snp)
    m1=match(common, d1$snp)
    m2=match(common, d2$snp)
    dat=data.frame(snp=common,
                   inflation=d1$chisq[m1]-d2$chisq[m2],
                   aver2=d1$aver2[m1])    
    
    # bin a variable by quantile
    cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average inflation by bin values
    out=data.frame(inflation_ave=tapply(dat$inflation,INDEX=dat$bin, mean))
    out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)

plot(out$bin_val, out$inflation_ave,
         xlab="ave r2", ylab="ave inflation",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg="orange", col="white", lwd=0.5)
 }
dev.off()

```

### chisq test statistics

```{r eval=F}

# QQ plot--------------------------------------------------------------------------
require(vroom)
cut="cut.125"
traits=c("awake","bmi","chron","ever",
       "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
        
png("fig/chisq-related-vs-unrel-real-data.png", res=600, width=50, height=30, units="cm")
par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5, pty="s")

for(i in 1:length(traits)){
  trait=traits[i]
  rel=vroom(paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out"), col_names=T)
  unrel=vroom(paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out"), col_names=T)
  m=match(rel$snp, unrel$snp)
  dat=data.frame(snp=rel$snp,
                 rel=rel$chisq,
                 unrel=unrel$chisq[m])

  # bin a variable by quantile
  cutoff1=quantile(dat$rel, probs = seq(0, 1, 0.01), na.rm=T)
  dat$bin_rel=cut(dat$rel, breaks=cutoff1, labels=1:(length(cutoff1)-1))
  cutoff2=quantile(dat$unrel, probs = seq(0, 1, 0.01), na.rm=T)
  dat$bin_unrel=cut(dat$unrel, breaks=cutoff2, labels=1:(length(cutoff2)-1))
  
  # average chisq by bin values
  ave=data.frame(rel=tapply(dat$rel,INDEX=dat$bin_rel, mean),
                 unrel=tapply(dat$unrel,INDEX=dat$bin_unrel, mean))
  sd=data.frame(rel=tapply(dat$rel,INDEX=dat$bin_rel, sd),
                 unrel=tapply(dat$unrel,INDEX=dat$bin_unrel, sd))
  # x ylim
  minimum=min(c(ave$rel,ave$unrel))
  maximum=max(c(ave$rel,ave$unrel))

  # plot
  plot(cutoff1, cutoff2,
           xlab="rel", ylab="unrel",
           main=trait, las=1,
           xlim=c(minimum, maximum),
           ylim=c(minimum, maximum),
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(0, 1, col="orange", lwd=2)
  #points(ave$rel, ave$unrel, cex = 1.5, pch=21, 
  #       bg="powderblue", col="white", lwd=0.5)
  
}
dev.off()
```

```{r eval=F}

# concordance between SNPs from related & unrelated individuals 

require(vroom)
cut="cut.125"
traits=c("awake","bmi","chron","ever",
       "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
        
png("fig/chisq-related-vs-unrel-concordance.png", res=600, width=50, height=30, units="cm")
par(mfrow=c(3,5), cex.lab=1.2, font.lab=2, cex.main=1.5, pty="s")

for(i in 1:length(traits)){
  trait=traits[i]
  rel=vroom(paste0("gwas-related-all-out/",trait,"-",cut,"-rel.out"), col_names=T)
  unrel=vroom(paste0("gwas-related-all-out/",trait,"-",cut,"-unrel.out"), col_names=T)
  m=match(rel$snp, unrel$snp)
  dat=data.frame(snp=rel$snp,
                 rel=rel$chisq,
                 unrel=unrel$chisq[m])

  # x ylim
  minimum=min(c(dat$rel,dat$unrel), na.rm=T)
  maximum=max(c(dat$rel,dat$unrel), na.rm=T)

  # plot
  plot(dat$rel, dat$unrel,
           xlab="rel", ylab="unrel",
           main=trait, las=1,
           xlim=c(minimum, maximum),
           ylim=c(minimum, maximum),
           cex = 0.4, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(0, 1, col="orange", lwd=1)
  #points(ave$rel, ave$unrel, cex = 1.5, pch=21, 
  #       bg="powderblue", col="white", lwd=0.5)
  
}
dev.off()

```



## mix unrel & rel

### genotype

```{bash eval=F}

# id list
awk '{print $1, $2}' rand.100000 icd10/related.inds > rel-unrel-combo.id 
# note: there are some overlap between the two id lists.

#:::
# make bfiles by chromosome
#::::
for j in {1..22}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --pfile ../gen/geno_plink/bhr$j \
         --keep ../rel-unrel-combo.id \
         --extract ../doug/ukbb.ldsc \
         --hwe 0.0001 \
         --hard-call-threshold .05 \
         --mach-r2-filter 0.8 2 \
         --make-bed \
         --memory 20000 \
         --out ../gen/tmp/bhr$j-combo \
         --threads 3 \
"> sh_script/chr$j.sh
done

# submit script
for i in {1..22}; do
sbatch -A snpher ../sh_script/chr$i.sh
done>../job-records/mkbfile-related-unrel-combo

# check job completion
file=job-records/mkbfile-related-unrel-combo
jobs=`awk '{print $4}' $file`
mkdir $file-tmp
for i in $jobs; do
jobinfo $i | awk -F ":" -v i=$i '$1~/Name/ {print i, $2}' >> $file-tmp/name.tmp 
jobinfo $i | awk -F ":" '$1~/State/ {print$2}' >> $file-tmp/state.tmp
jobinfo $i | awk -F ":" '$1~/Cores/ {print$2}' >> $file-tmp/cores.tmp
jobinfo $i | awk -F ":" '$1~/Used walltime/ {print $2 ":" $3 ":" $4}' >> $file-tmp/time.tmp
jobinfo $i | awk -F ":" '$1~/Max Mem/ {split($2,a,/[(]/ ); print a[1]}' >> $file-tmp/mem.tmp
done
paste $file-tmp/name.tmp \
      $file-tmp/state.tmp \
      $file-tmp/cores.tmp \
      $file-tmp/time.tmp \
      $file-tmp/mem.tmp \
      | awk 'BEGIN{print "ID name state cores time mem"}{print $0}' > $file.out
rm -r $file-tmp

#:::::
# merge bfiles 
#::::

rm bfile.list
for j in {1..22}; do
echo  "../gen/tmp/bhr$j-combo" >>bfile.list
done

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 40:0:0
./ldak5.1 --make-bed ../gen/geno-rel-unrel-combo \
          --mbfile ../gen/bfile.list \
          --max-threads 3 \
          --exclude-dups YES  
"> sh_script/mbfile.sh


# snp list --------------------------------------------------------------------

# MAF & call-rate 
awk < gen/geno-rel-unrel-combo.stats '($5>.01 && $6>=0.95 && NR>1){print $1}' > gen/snps-rel-unrel-combo.use
# m = 1,102,906 SNPs

```

### gwas

```{bash eval=F}

mkdir gwas-rel-unrel-combo

# script ----------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for chr in {1..22}; do
snp=../gen/snps-rel-unrel-combo.use
bfile=../gen/geno-rel-unrel-combo
out=../gwas-rel-unrel-combo/$i-linear-$chr

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 1
#SBATCH -t 8:0:0

./ldak5.1 --linear $out \
          --pheno ../phen/continuous-traits/$i.raw.pheno \
          --bfile $bfile \
          --extract $snp \
          --covar ../phen/basic-covariates.use \
          --max-threads 2 \
          --chr $chr
"> sh_script/$i-linear-chr-$chr.sh
done
done
#done

# submit jobs-------------------------------------------------------------------
for i in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
for chr in {1..22}; do
sbatch -A snpher ../sh_script/$i-linear-chr-$chr.sh
done
done>../job-records/gwas-combo

# merge files-------------------------------------------------------------------

# only do .summaries & .pvalues
for i in {awake,bmi,quals,chron,ever,fvc,height,imp,neur,pulse,reaction,sbp,snoring,hyper}; do 
for j in {1..22}; do
if [ $j == 1 ]; then
  awk '{print $0}' $i-linear-$j.summaries > $i-linear.summaries
  awk '{print $0}' $i-linear-$j.pvalues > $i-linear.pvalues
else 
  awk 'NR>1 {print $0}' $i-linear-$j.summaries >> $i-linear.summaries
  awk 'NR>1 {print $0}' $i-linear-$j.pvalues >> $i-linear.pvalues
fi
done
done

```

### aver2_j

```{bash eval=F}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  snp lists
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# common snps of related & unrelated
unrel=gen/snps-unrel-inds.use
rel=gen/snps-rel-unrel-combo.use
awk 'NR==FNR{a[$1];next} 
    ($1 in a) {print $1}' $unrel $rel > gen/common-unrel-rel-combo-snps # 1,101,883

# lista & listb
m=10000
infile=gen/common-unrel-rel-combo-snps
left=inflation/combo/left-snps
right=inflation/combo/right-snps

awk '{split($1, a, ":");
    if (a[1]<8) print $1 }' $infile | shuf | head -n $m >$left  
awk '{split($1, a, ":");
    if (a[1]>=8) print $1 }' $infile | shuf | head -n $m >$right
  
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#  compute ave r^2_j
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# related
lista=../inflation/combo/right-snps
listb=../inflation/combo/left-snps
bfile=../gen/geno-rel-unrel-combo
out=../inflation/combo/out/10k-snps

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 2
#SBATCH -t 00:30:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --bfile $bfile \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps

# submit the job
sbatch -A snpher ../sh_script/calc-r-10k-snps >../job-records/calc-r-combo

# unrelated
lista=../inflation/combo/right-snps
listb=../inflation/combo/left-snps
bfile=../gen/geno-unrel
id=../unrelated/rand.100000
out=../inflation/combo/out/10k-snps-unrel

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 2
#SBATCH -t 00:10:0
./ldak5.2 --max-threads 2 \
          --calc-inflation $out \
          --keep $id \
          --bfile $bfile \
          --lista $lista \
          --listb $listb
">sh_script/calc-r-10k-snps-unrel

# submit the job
sbatch -A snpher ../sh_script/calc-r-10k-snps-unrel >../job-records/calc-r-combo-unrel

#  compute ave r_j^2 for each i-------------------------------------------------
R
require(vroom)

nm="10k-snps"
dat=vroom(paste0("inflation/combo/out/",nm,".pairwise"), col_names=F)
lista=read.table(paste0("inflation/combo/out/",nm,".predictorsa"), 
                stringsAsFactors = F)
listb=read.table(paste0("inflation/combo/out/",nm,".predictorsb"), 
                stringsAsFactors = F)

dat=dat[,-c(10001)]^2
outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
out=rbind(outa,outb)

write.table(out,paste0("summary/ave-r2-",nm, "-rel-unrel-combo"), col.names=F, row.names=F, quote=F) 

# for unrelated control rand.100000
R
require(vroom)
nm="10k-snps-unrel"
dat=vroom(paste0("inflation/combo/out/",nm,".pairwise"), col_names=F)
lista=read.table(paste0("inflation/combo/out/",nm,".predictorsa"), 
                stringsAsFactors = F)
listb=read.table(paste0("inflation/combo/out/",nm,".predictorsb"), 
                stringsAsFactors = F)

dat=dat[,-c(10001)]^2
outb=data.frame(predictor=listb$V1, ave_r2=apply(dat,2, mean))
outa=data.frame(predictor=lista$V1, ave_r2=apply(dat,1, mean))
out=rbind(outa,outb)

write.table(out,"summary/ave-r2-10k-snps-rel-unrel-combo-ref", 
            col.names=F, row.names=F, quote=F) 

```

### organize data

```{bash eval=F}

# related------------------------------------------------------------------------
for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

gwas=gwas-rel-unrel-combo/$trait-linear.summaries
aver2=summary/ave-r2-10k-snps-rel-unrel-combo
out=gwas-rel-unrel-combo-out/$trait.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp    

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done

# unrelated control-------------------------------------------------------------
for trait in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do

gwas=unrelated/gwas-good/$trait-linear.summaries
aver2=summary/ave-r2-10k-snps-rel-unrel-combo-ref
out=gwas-rel-unrel-combo-out/$trait-ref.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp    

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2"}
             {$1=$1}1' > $out
done

```

### chisq ~ aver2_j

```{bash eval=F}

#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: chisq ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(traits)){

trait=traits[i]

file=paste0("gwas-rel-unrel-combo-out/",trait,".out")

dat=vroom(file, col_names=T, delim=";")
dat=dat[complete.cases(dat),]
mod=lm(chisq ~ aver2,data=dat)

slope0=data.frame(trait=trait,
                  slope_aver2=coef(mod)[2],
                  p_aver2=summary(mod)$coefficients[,4][2],
                  stringsAsFactors = F)

if(i==1){slope=slope0} else {slope=rbind(slope,slope0)}

}

#::::::::::::::::::::::::::::::::::::::::::::::
# plot chisq ~ aver2_j  
#::::::::::::::::::::::::::::::::::::::::::::::
# make a plot ------------------------------------------------------------------
require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
        
png(paste0("fig/chisq-by-aver2-bin-unrel-rel-combo-gwas.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))

for (i in 1:length(traits)){
    trait=traits[i]
    file=paste0("gwas-rel-unrel-combo-out/",trait,".out")
    dat=vroom(file, col_names=T, delim=";")
    # bin a variable by quantile
    cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average chisq by bin values
    out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
    out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)

plot(out$bin_val, out$chisq_ave,
         xlab="ave r2", ylab="ave chisq",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg="orange", col="white", lwd=0.5)
 }
dev.off()
```

### inflation ~ aver2_j

```{r eval=F}
#::::::::::::::::::::::::::::::::::::::::::::::
# estimate slope: inflation ~ aver2_j
#::::::::::::::::::::::::::::::::::::::::::::::

require(vroom)

traits=c("awake","bmi","chron","ever",
       "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")

for(i in 1:length(traits)){

    trait=traits[i]
    f1=paste0("gwas-rel-unrel-combo-out/",trait,".out")
    f2=paste0("gwas-rel-unrel-combo-out/",trait,"-ref.out")
    d1=vroom(f1, col_names=T, delim=";")
    d2=vroom(f2, col_names=T, delim=";")
    common=intersect(d1$snp, d2$snp)
    m1=match(common, d1$snp)
    m2=match(common, d2$snp)
    dat=data.frame(snp=common,
                   inflation=d1$chisq[m1]-d2$chisq[m2],
                   aver2=d1$aver2[m1])
    
    mod=lm(inflation ~ aver2,data=dat)
  
    slope0=data.frame(trait=trait,
                      slope_aver2=coef(mod)[2],
                      p_aver2=summary(mod)$coefficients[,4][2],
                      stringsAsFactors = F)
    
    if(i==1){slope=slope0} else {slope=rbind(slope,slope0)}
    
}


out=slope[order(slope$trait),]

#::::::::::::::::::::::::::::::::::::::::::::::
# plot inflation ~ aver2_j  
#::::::::::::::::::::::::::::::::::::::::::::::
# make a plot ------------------------------------------------------------------
require(vroom)
traits=c("awake","bmi","chron","ever",
        "neur","pulse","quals", "fvc", "height","imp", 
        "reaction","sbp","snoring","hyper")
     
png(paste0("fig/inflation-by-aver2-bin-rel-unrel-combo.png"),
      width = 50, height = 30, units = "cm", res=600)
  par(mfrow=c(3,5))
for (i in 1:length(traits)){

    trait=traits[i]
    f1=paste0("gwas-rel-unrel-combo-out/",trait,".out")
    f2=paste0("gwas-rel-unrel-combo-out/",trait,"-ref.out")
    d1=vroom(f1, col_names=T, delim=";")
    d2=vroom(f2, col_names=T, delim=";")
    common=intersect(d1$snp, d2$snp)
    m1=match(common, d1$snp)
    m2=match(common, d2$snp)
    dat=data.frame(snp=common,
                   inflation=d1$chisq[m1]-d2$chisq[m2],
                   aver2=d1$aver2[m1])    
    
    # bin a variable by quantile
    cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
    dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
    # average inflation by bin values
    out=data.frame(inflation_ave=tapply(dat$inflation,INDEX=dat$bin, mean))
    out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)

plot(out$bin_val, out$inflation_ave,
         xlab="ave r2", ylab="ave inflation",
         main=trait, las=1,
         cex = 1.5, pch=21,  bg="orange", col="white", lwd=0.5)
 }
dev.off()

```

## fake quintuplets

To introduce extremely high relatedness into the genotype data, we duplicate each of 20k unrelated white British five times. Note these 20k should be free from confounding by pop structure. So the 20k individuals are unrelated white British who are similar on PC1.

### id lists

```{bash eval=F}

mkdir fake-quintuplets

# id list with completed data--------------------------------------------------- 
cp ukbb-recommend.id fake-quintuplets/ukbb-recommend-overlap.ind # unrelated white British

dir=phen/continuous-traits/
outdir=fake-quintuplets
for tt in {awake,bmi,chron,ever,fvc,height,imp,neur,pulse,quals,reaction,sbp,snoring,hyper}; do
mv $outdir/ukbb-recommend-overlap.ind $outdir/temp
awk '(NR==FNR){a[$1];next}($1 in a){print $1, $2}' $outdir/temp $dir/$tt.raw.pheno > $outdir/ukbb-recommend-overlap.ind
wc -l $outdir/ukbb-recommend-overlap.ind
echo $tt
done
rm $outdir/temp
# overlapping + complete data for covariates + unrelated
awk 'NR==FNR{a[$1]; next} ($1 in a) {print $1, $1}' $outdir/ukbb-recommend-overlap.ind white-complete-cov.id > $outdir/ukbb-recommend-overlap-complete-cov.id # N = 196,333

# homogenous in PC1 ------------------------------------------------------------ 
R
options(scipen = 100)
id=read.table("fake-quintuplets/ukbb-recommend-overlap-complete-cov.id", header=F)
pc=read.table("gen/pca-337k-ukbb.eigenvec", header=F)
names(pc)=c("eid", "eid", paste0("PC", 1:10))
m=match(id$V1,pc[,1])
pc=pc[m,]

dat=pc[order(pc$PC1, decreasing=T),]
out=rbind(dat[1:20000,1:2])

# final list
write.table(out, "fake-quintuplets/unrelated-white-homogenous-pc1-20k.id", 
col.names=F, row.names=F, quote=F)

```

### make bfiles

```{bash eval=F}
mkdir fake-quintuplets/gen

# make-bfiles of the 20k unrelated----------------------------------------------
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --bfile ../gen/geno-norm \
         --keep ../fake-quintuplets/unrelated-white-homogenous-pc1-20k.id \
         --extract ../gen/snps-norm.use \
         --make-bed \
         --memory 20000 \
         --out ../fake-quintuplets/gen/unrel-20k \
         --threads 3 \
"> sh_script/make-bed-unrel-20k.sh

# submit script
sbatch -A snpher ../sh_script/make-bed-unrel-20k.sh > ../job-records/make-bed-unrel-20k.sh

# make 5 copies of bfile of the 20k unrelated----------------------------------------------
dir=fake-quintuplets/gen
for copy in {a,b,c,d,e}; do
awk -v copy=$copy '{print copy$1, $2, $3, $4, $5, $6}' $dir/unrel-20k.fam > $dir/unrel-20k-$copy.fam
done

cd $dir
for copy in {a,b,c,d,e}; do
ln -s unrel-20k.bim unrel-20k-$copy.bim
ln -s unrel-20k.bed unrel-20k-$copy.bed
done

# combine data----------------------------------------------------------------------
echo "../fake-quintuplets/gen/unrel-20k-a
../fake-quintuplets/gen/unrel-20k-b
../fake-quintuplets/gen/unrel-20k-c
../fake-quintuplets/gen/unrel-20k-d
../fake-quintuplets/gen/unrel-20k-e
"> fake-quintuplets/gen/bmerge-list


echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 40G
#SBATCH -c 3
#SBATCH -t 1:0:0
./plink1.9 --merge-list ../fake-quintuplets/gen/bmerge-list \
         --make-bed \
         --out ../fake-quintuplets/gen/20k-quintuplets \
         --threads 3
"> sh_script/merge.sh

sbatch -A snpher ../sh_script/merge.sh > ../job-records/merge.sh

```

### simulate phenotypes

```{bash eval=F}

mkdir fake-quintuplets/sim-her-0.5

bfile=../fake-quintuplets/gen/20k-quintuplets
her=0.5
out=../fake-quintuplets/sim-her-0.5/sim

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 3
#SBATCH -t 10:0:0

./ldak5.1 --make-phenos $out \
          --bfile $bfile \
          --ignore-weights YES \
          --power -1 \
          --her $her \
          --num-phenos 100 \
          --num-causals 10000
"> sh_script/sim.sh
done

sbatch -A snpher ../sh_script/sim.sh > ../job-records/sim.sh

# put simulated phenotypes into seperate files----------------------------------
mkdir fake-quintuplets/sim-her-0.5/phen

dir=fake-quintuplets/sim-her-0.5
for i in {1..100}; do
awk -v col=$i '{print $1, $2, $(col+2)}' $dir/sim.pheno > $dir/phen/sim-$i.pheno
done

```

```{r eval=F}

# check if the simulation is done correctly

# we would expect breeding values are the same for the same individuals
# Yes!
require(vroom)

dat=vroom("fake-quintuplets/sim-her-0.5/sim.breed", col_names=F)
dat$group=c(rep("a", 20000),rep("b", 20000),rep("c", 20000),
            rep("d", 20000), rep("e", 20000))
sel=dat[,c("X1", "X3", "group")]
cor(sel[sel$group=="a", "X3"],sel[sel$group=="b", "X3"])
cor(sel[sel$group=="a", "X3"],sel[sel$group=="c", "X3"])

# expect correlation between simulated phenotypes is 0.5
dat=vroom("fake-quintuplets/sim-her-0.5/sim.pheno", col_names=F)
dat$group=c(rep("a", 20000),rep("b", 20000),rep("c", 20000),
            rep("d", 20000), rep("e", 20000))
sel=dat[,c("X1", "X3", "group")]
cor(sel[sel$group=="a", "X3"],sel[sel$group=="b", "X3"])
cor(sel[sel$group=="a", "X3"],sel[sel$group=="c", "X3"])

```

### gwas

```{bash eval=F}

mkdir fake-quintuplets/sim-her-0.5/gwas

dir=../fake-quintuplets/sim-her-0.5
bfile=../fake-quintuplets/gen/20k-quintuplets
for i in {1..10}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 3
#SBATCH -t 10:0:0

./ldak5.1 --linear $dir/gwas/sim-$i \
          --pheno $dir/phen/sim-$i.pheno \
          --bfile $bfile \
          --max-threads 3 \
"> sh_script/sim-$i-gwas.sh
done

# submit files
for i in {1..10}; do
sbatch -A snpher ../sh_script/sim-$i-gwas.sh
done>../job-records/gwas-sim

```

### compute aver2

```{bash eval=F}
# new directory
mkdir fake-quintuplets/sim-her-0.5/
mkdir fake-quintuplets/sim-her-0.5/aver2

# to calc aver2 for lista-------------------------------------------------------
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps
bfile=../fake-quintuplets/gen/20k-quintuplets
out=../fake-quintuplets/sim-her-0.5/aver2/lista

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 7
#SBATCH -t 00:40:0
./ldak5.2 --max-threads 7 \
          --calc-inflation $out \
          --bfile $bfile \
          --lista $lista \
          --listb $listb
">sh_script/calc-aver2-lista

# job submission
sbatch -A snpher ../sh_script/calc-aver2-lista >../job-records/calc-aver2-sim

# to calc aver2 for listb-------------------------------------------------------
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps
bfile=../fake-quintuplets/gen/20k-quintuplets
out=../fake-quintuplets/sim-her-0.5/aver2/listb

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 7
#SBATCH -t 00:40:0
./ldak5.2 --max-threads 7 \
          --calc-inflation $out \
          --bfile $bfile \
          --lista $listb \
          --listb $lista
">sh_script/calc-aver2-listb

# job submission
sbatch -A snpher ../sh_script/calc-aver2-listb >../job-records/calc-aver2-sim

# merge aver2 of the two lists--------------------------------------------------
dir=fake-quintuplets/sim-her-0.5/aver2
a=$dir/lista.rjk2.average
b=$dir/listb.rjk2.average
out=$dir/all.aver2
awk 'FNR > 1 {print $1, $2}'  $a $b > $out
```

### chisq ~ aver2

```{bash eval=F}

# organize data ---------------------------------------------------------------

mkdir fake-quintuplets/sim-her-0.5/gwas-out

outdir=fake-quintuplets/sim-her-0.5/gwas-out
indir=fake-quintuplets/sim-her-0.5

for i in {1..10}; do

gwas=$indir/gwas/sim-$i.summaries
aver2=$indir/aver2/all.aver2
ldsc=snps-norm.ldscore
out=$outdir/sim-$i.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $ldsc tmp/gwas.tmp > tmp/ldsc.tmp

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      tmp/ldsc.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2;ldsc"}
             {$1=$1}1' > $out
done

```

### intercept & slope estimates

We noted below that if we use only SNPs chosen to compute aver2, the intercept estimate does not differ from 1, because the standard error is large. However, when we use genome-wide SNPs, the intercepts deviate from 1. Should we use genome-wide SNPs for the new method?

```{r eval=F}

# chisq ~ aver2 bin

require(vroom)

png("fig/chisq-aver2-bin-rel-sim.png", res=600, width=50, height=20, units="cm")
par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(i in 1:10){

  dat=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,".out"), col_names=T)
  dat=dat[complete.cases(dat),]

  # linear model
  mod=lm(chisq ~ ldsc, data= dat)
  mod=lm(chisq ~ aver2 + ldsc,data=dat)
  p=summary(mod)$coefficients[,4][2]
  p_sci=formatC(p, format="e", digit=2)

  # bin a variable by quantile
  cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
  
  # average chisq by bin values
  out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
  out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
  px=min(out$bin_val)
  py=max(out$chisq_ave)

  # plot
  plot(out$bin_val, out$chisq_ave,
           xlab="ave r2 bin", ylab="mean chisq",
           main=paste0("sim ",i), las=1,
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(lm(chisq ~ aver2, data=dat),col="orange", lwd=2)
  if(p<0.01){text(px, py, paste0("p = ", p_sci),
                  adj=c(0,1), col="red", cex=2, font=2)
    } else {text(px, py, paste0("p = ", p_sci), 
          adj=c(0,1), cex=2, font=2)}
  
}
dev.off()

```

```{r eval=F}
# estimate intercept & slope
# chisq ~ aver2 + ldsc
require(vroom)

for(i in 1:10){

  dat=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,".out"), col_names=T)

  # linear model
  mod=lm(chisq ~ aver2 + ldsc,data=dat)
  
  
  # collect output
  out0=data.frame(sim=i,
                  a0=summary(mod)$coefficients[1,1],
                  a0_se=summary(mod)$coefficients[1,2],
                  a1=summary(mod)$coefficients[2,1],
                  a1_se=summary(mod)$coefficients[2,2],
                  a1_p=summary(mod)$coefficients[2,4])
  out0$a0_p=pchisq(((out0$a0-1)/out0$a0_se)^2, df=1, lower.tail=F)
  
  if(i==1){out=out0} else{out=rbind(out,out0)}
  
}

# ldscore regression only------------------------------------------------------

# chisq ~ ldsc
require(vroom)

for(i in 1:10){
  
  dat=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,"-gwaver2.out"), col_names=T)

  
  # linear model
  mod=lm(chisq ~ ldsc,data=dat)
  
  # collect output
  out0=data.frame(sim=i,
                  a0=summary(mod)$coefficients[1,1],
                  a0_se=summary(mod)$coefficients[1,2])
  out0$a0_p=pchisq(((out0$a0-1)/out0$a0_se)^2, df=1, lower.tail=F)
  
  if(i==1){ldsc=out0} else{ldsc=rbind(ldsc,out0)}
  
}

# mod comparison----------------------------------------------------------------

# chisq ~ ldsc
require(vroom)

for(i in 1:10){
  
  dat=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,"-gwaver2.out"), col_names=T)
  dat=dat[complete.cases(dat),]
  
  # linear model
  mod1=lm(chisq ~ ldsc, data=dat)
  mod2=lm(chisq ~ aver2 + ldsc, data=dat)
  
  # collect output
  compare0=data.frame(sim=i,
                     p=anova(mod1,mod2)$Pr[2])
  
  if(i==1){compare=compare0} else{compare=rbind(compare,compare0)}
  
}

```

## unrelated controls

### id lists
```{r eval=F}
options(scipen = 100)
id=read.table("fake-quintuplets/ukbb-recommend-overlap-complete-cov.id", header=F)
pc=read.table("gen/pca-337k-ukbb.eigenvec", header=F)
names(pc)=c("eid", "eid", paste0("PC", 1:10))
m=match(id$V1,pc[,1])
pc=pc[m,]

dat=pc[order(pc$PC1, decreasing=T),]
out=rbind(dat[1:100000,1:2])

# final list
write.table(out, "fake-quintuplets/unrelated-white-homogenous-pc1-100k.id", 
col.names=F, row.names=F, quote=F)

```

### make bfiles

```{bash eval=F}

# make-bfiles of the 100k unrelated----------------------------------------------
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 20G
#SBATCH -c 3
#SBATCH -t 1:0:0

./plink2 --bfile ../gen/geno-norm \
         --keep ../fake-quintuplets/unrelated-white-homogenous-pc1-100k.id \
         --extract ../gen/snps-norm.use \
         --make-bed \
         --memory 20000 \
         --out ../fake-quintuplets/gen/unrel-100k \
         --threads 3 \
"> sh_script/make-bed-unrel-100k.sh

# submit script
sbatch -A snpher ../sh_script/make-bed-unrel-100k.sh > ../job-records/make-bed-unrel-100k.sh

```

### simulate phenotypes

```{bash eval=F}

mkdir fake-quintuplets/sim-her-0.5-unrel

bfile=../fake-quintuplets/gen/unrel-100k
out=../fake-quintuplets/sim-her-0.5-unrel/sim
her=0.5
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 3
#SBATCH -t 10:0:0

./ldak5.1 --make-phenos $out \
          --bfile $bfile \
          --ignore-weights YES \
          --power -1 \
          --her $her \
          --causals \
          --effects  \
          --num-phenos 100 \
          --num-causals 10000
"> sh_script/sim.sh

sbatch -A snpher ../sh_script/sim.sh > ../job-records/sim.sh

# put simulated phenotypes into separate files----------------------------------
mkdir fake-quintuplets/sim-her-0.5-unrel/phen

dir=fake-quintuplets/sim-her-0.5-unrel
for i in {1..100}; do
awk -v col=$i '{print $1, $2, $(col+2)}' $dir/sim.pheno > $dir/phen/sim-$i.pheno
done

```

### gwas

```{bash eval=F}

mkdir fake-quintuplets/sim-her-0.5-unrel/gwas

dir=../fake-quintuplets/sim-her-0.5-unrel
bfile=../fake-quintuplets/gen/unrel-100k
for i in {1..10}; do
echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 8G
#SBATCH -c 3
#SBATCH -t 10:0:0

./ldak5.1 --linear $dir/gwas/sim-$i \
          --pheno $dir/phen/sim-$i.pheno \
          --bfile $bfile \
          --max-threads 3 \
"> sh_script/sim-$i-gwas.sh
done

# submit files
for i in {1..10}; do
sbatch -A snpher ../sh_script/sim-$i-gwas.sh
done>../job-records/gwas-sim

```

### compute aver2

```{bash eval=F}

mkdir fake-quintuplets/sim-her-0.5-unrel/aver2

# to calc aver2 for lista-------------------------------------------------------
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps
bfile=../fake-quintuplets/gen/unrel-100k
out=../fake-quintuplets/sim-her-0.5-unrel/aver2/lista

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 7
#SBATCH -t 00:40:0
./ldak5.2 --max-threads 7 \
          --calc-inflation $out \
          --bfile $bfile \
          --lista $lista \
          --listb $listb
">sh_script/calc-aver2-lista

# job submission
sbatch -A snpher ../sh_script/calc-aver2-lista >../job-records/calc-aver2-sim

# to calc aver2 for listb-------------------------------------------------------
lista=../inflation/related/right-snps
listb=../inflation/related/left-snps
id=../british-irish-gwas.id 
bfile=../fake-quintuplets/gen/unrel-100k
out=../fake-quintuplets/sim-her-0.5-unrel/aver2/listb

echo "#"'!'"/bin/bash
#SBATCH --constraint \"s04|s05\"
#SBATCH --partition normal
#SBATCH --mem 30G
#SBATCH -c 7
#SBATCH -t 00:40:0
./ldak5.2 --max-threads 7 \
          --calc-inflation $out \
          --bfile $bfile \
          --lista $listb \
          --listb $lista
">sh_script/calc-aver2-listb

# job submission
sbatch -A snpher ../sh_script/calc-aver2-listb >../job-records/calc-aver2-sim

# merge aver2 of the two lists--------------------------------------------------
dir=fake-quintuplets/sim-her-0.5-unrel/aver2
a=$dir/lista.rjk2.average
b=$dir/listb.rjk2.average
out=$dir/all.aver2
awk 'FNR > 1 {print $1, $2}'  $a $b > $out

```

### chisq ~ aver2

```{bash eval=F}

# organize data ---------------------------------------------------------------

mkdir fake-quintuplets/sim-her-0.5-unrel/gwas-out

outdir=fake-quintuplets/sim-her-0.5-unrel/gwas-out
indir=fake-quintuplets/sim-her-0.5-unrel

for i in {1..10}; do

gwas=$indir/gwas/sim-$i.summaries
aver2=$indir/aver2/all.aver2
ldsc=snps-norm.ldscore
out=$outdir/sim-$i.out

awk 'NR>1 {print $1, $5}' $gwas > tmp/gwas.tmp

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $ldsc tmp/gwas.tmp > tmp/ldsc.tmp

awk 'NR==FNR {a[$1]; b[$1]=$2; next} 
     {if ($1 in a) print b[$1]; 
     else print "NA" }' $aver2 tmp/gwas.tmp > tmp/aver2.tmp

# put info together
paste tmp/gwas.tmp \
      tmp/aver2.tmp \
      tmp/ldsc.tmp \
      | awk 'BEGIN{OFS=";" ; 
                  print "snp;chisq;aver2;ldsc"}
             {$1=$1}1' > $out
done

```

```{r eval=F}

# chisq ~ aver2 bin

require(vroom)

png("fig/chisq-aver2-bin-sim-unrel-control.png", res=600, width=50, height=20, units="cm")
par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(i in 1:10){

  dat=vroom(paste0("fake-quintuplets/sim-her-0.5-unrel/gwas-out/sim-",i,".out"), col_names=T)
  dat=dat[complete.cases(dat),]

  # linear model
  mod=lm(chisq ~ aver2 + ldsc,data=dat)
  p=summary(mod)$coefficients[,4][2]
  p_sci=formatC(p, format="e", digit=2)

  # bin a variable by quantile
  cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
  
  # average chisq by bin values
  out=data.frame(chisq_ave=tapply(dat$chisq,INDEX=dat$bin, mean))
  out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
  px=min(out$bin_val)
  py=max(out$chisq_ave)

  # plot
  plot(out$bin_val, out$chisq_ave,
           xlab="ave r2 bin", ylab="mean chisq",
           main=paste0("sim ",i), las=1,
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(lm(chisq ~ aver2, data=dat),col="orange", lwd=2)
  if(p<0.01){text(px, py, paste0("p = ", p_sci),
                  adj=c(0,1), col="red", cex=2, font=2)
    } else {text(px, py, paste0("p = ", p_sci), 
          adj=c(0,1), cex=2, font=2)}
  
}
dev.off()

```

## related vs. unrelated

### chisq test statistics
```{r eval=F}

# QQ plot--------------------------------------------------------------------------
require(vroom)

png("fig/chisq-related-vs-unrel.png", res=600, width=50, height=20, units="cm")
par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5, pty="s")

for(i in 1:10){

  rel=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,".out"), col_names=T)
  unrel=vroom(paste0("fake-quintuplets/sim-her-0.5-unrel/gwas-out/sim-",i,".out"), col_names=T)
  m=match(rel$snp, unrel$snp)
  dat=data.frame(snp=rel$snp,
                 rel=rel$chisq,
                 unrel=unrel$chisq[m])

  # bin a variable by quantile
  cutoff1=quantile(dat$rel, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin_rel=cut(dat$rel, breaks=cutoff1, labels=1:(length(cutoff1)-1))
  cutoff2=quantile(dat$unrel, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin_unrel=cut(dat$unrel, breaks=cutoff2, labels=1:(length(cutoff2)-1))
  
  # average chisq by bin values
  ave=data.frame(rel=tapply(dat$rel,INDEX=dat$bin_rel, mean),
                 unrel=tapply(dat$unrel,INDEX=dat$bin_unrel, mean))
  sd=data.frame(rel=tapply(dat$rel,INDEX=dat$bin_rel, sd),
                 unrel=tapply(dat$unrel,INDEX=dat$bin_unrel, sd))
  # x ylimminimum=min(c(ave$rel,ave$unrel))
  
  maximum=max(c(ave$rel,ave$unrel))

  # plot
  plot(cutoff1, cutoff2,
           xlab="rel", ylab="unrel",
           main=paste0("sim ",i), las=1,
           xlim=c(minimum, maximum),
           ylim=c(minimum, maximum),
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(0, 1, col="orange", lwd=2)
  #points(ave$rel, ave$unrel, cex = 1.5, pch=21, 
  #       bg="powderblue", col="white", lwd=0.5)
  
}
dev.off()

```

### aver2

```{r eval=F}
require(vroom)
rel=vroom("fake-quintuplets/sim-her-0.5/aver2/all.aver2", col_names=F)
unrel=vroom("fake-quintuplets/sim-her-0.5-unrel/aver2/all.aver2", col_names=F)
m=match(rel$X1, unrel$X1)
dat=data.frame(snp=rel$X1, 
               rel=rel$X2,
               unrel=unrel$X2[m])
apply(dat[,2:3], 2, mean)

# quantiles
q_rel=quantile(dat$rel, probs = seq(0, 1, 0.005), na.rm=T)
q_unrel=quantile(dat$unrel, probs = seq(0, 1, 0.005), na.rm=T)

minimum=min(c(q_rel,q_unrel))
maximum=max(c(q_rel,q_unrel))

png("fig/aver2-related-vs-unrel.png", res=600, width=30, height=20, units="cm")
par(cex.lab=1.2, font.lab=2, cex.main=1.5, pty="s")
  plot(q_rel, q_unrel,
           xlab="rel", ylab="unrel",
           main="", las=1,
           xlim=c(minimum, maximum),
           ylim=c(minimum, maximum),
           cex = 1.5, pch=16,  col="darkgray", lwd=0.5)
  abline(0, 1, col="orange", lwd=2)
  
dev.off()
 
```

### inflation ~ aver2

```{r eval=F}

require(vroom)

png("fig/inflation-aver2-bin-rel-sim.png", res=600, width=50, height=20, units="cm")
par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(i in 1:10){

  rel=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,".out"), col_names=T)
  unrel=vroom(paste0("fake-quintuplets/sim-her-0.5-unrel/gwas-out/sim-",i,".out"), col_names=T)
  m=match(rel$snp,unrel$snp)
  dat=data.frame(rel$snp,
                 inflation=rel$chisq-unrel$chisq[m],
                 aver2=rel$aver2,
                 ldsc=rel$ldsc)
  dat=dat[complete.cases(dat),]

  # linear model
  mod=lm(inflation ~ aver2 ,data=dat)
  p=summary(mod)$coefficients[,4][2]
  p_sci=formatC(p, format="e", digit=2)

  # bin a variable by quantile
  cutoff=quantile(dat$aver2, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin=cut(dat$aver2, breaks=cutoff, labels=1:(length(cutoff)-1))
  
  # average chisq by bin values
  out=data.frame(inflation_ave=tapply(dat$inflation,INDEX=dat$bin, mean))
  out$bin_val=tapply(dat$aver2,INDEX=dat$bin, mean)
  px=min(out$bin_val)
  py=max(out$inflation_ave)

  # plot
  plot(out$bin_val, out$inflation_ave,
           xlab="ave r2 bin", ylab="mean inflation",
           main=paste0("sim ",i), las=1,
           cex = 1.5, pch=21,  bg="darkgray", col="white", lwd=0.5)
  abline(mod,col="orange", lwd=2)
  if(p<0.01){text(px, py, paste0("p = ", p_sci),
                  adj=c(0,1), col="red", cex=2, font=2)
    } else {text(px, py, paste0("p = ", p_sci), 
          adj=c(0,1), cex=2, font=2)}
  
}
dev.off()

```

### chisq ~ ldscore

```{r eval=F}

require(vroom)

png("fig/chisq-ldsc-bin-rel-sim.png", res=600, width=50, height=20, units="cm")
par(mfrow=c(2,5), cex.lab=1.2, font.lab=2, cex.main=1.5)

for(i in 1:10){

  rel=vroom(paste0("fake-quintuplets/sim-her-0.5/gwas-out/sim-",i,".out"), col_names=T)
  unrel=vroom(paste0("fake-quintuplets/sim-her-0.5-unrel/gwas-out/sim-",i,".out"), col_names=T)
  m=match(rel$snp,unrel$snp)
  dat=data.frame(snp=rel$snp,
                 rel=rel$chisq,
                 unrel=unrel$chisq[m],
                 ldsc=rel$ldsc)

  # bin a variable by quantile
  cutoff=quantile(dat$ldsc, probs = seq(0, 1, 0.005), na.rm=T)
  dat$bin=cut(dat$ldsc, breaks=cutoff, labels=1:(length(cutoff)-1))
  
  # average chisq by bin values
  out=data.frame(rel_ave=tapply(dat$rel,INDEX=dat$bin, mean),
                 unrel_ave=tapply(dat$unrel,INDEX=dat$bin, mean))
  out$bin_val=tapply(dat$ldsc,INDEX=dat$bin, mean)

  # plot
  plot(out$bin_val, out$rel_ave,
           xlab="ldsc bin", ylab="mean chisq",
           xlim=c(min(out$bin_val), max(out$bin_val)),
           ylim=c(0, max(out$rel_ave,out$unrel_ave)),
           main=paste0("sim ",i), las=1,
           cex = 1.5, pch=21,  bg="orange", col="white", lwd=0.5)
  points(out$bin_val, out$unrel_ave, cex = 1.5, pch=21, 
         bg="darkgrey", col="white", lwd=0.5)
  
}
dev.off()

```

